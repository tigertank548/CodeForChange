{"version":3,"file":"lib.umd.js","sources":["../src/BaseConversation.ts","../src/utils/BaseConnection.ts","../src/version.ts","../src/utils/events.ts","../src/utils/overrides.ts","../src/utils/errors.ts","../src/utils/WebSocketConnection.ts","../src/utils/audio.ts","../src/utils/createWorkletModuleLoader.ts","../src/utils/rawAudioProcessor.generated.ts","../src/utils/WebRTCConnection.ts","../src/utils/ConnectionFactory.ts","../src/utils/compatibility.ts","../src/utils/applyDelay.ts","../src/TextConversation.ts","../src/utils/input.ts","../src/utils/audioConcatProcessor.generated.ts","../src/utils/output.ts","../src/VoiceConversation.ts","../src/scribe/connection.ts","../src/scribe/scribe.ts","../src/utils/scribeAudioProcessor.generated.ts","../src/index.ts","../src/utils/postOverallFeedback.ts"],"sourcesContent":["import { Callbacks, Mode, Status } from \"@elevenlabs/types\";\nimport type {\n  BaseConnection,\n  DisconnectionDetails,\n  SessionConfig,\n  FormatConfig,\n} from \"./utils/BaseConnection\";\nimport type {\n  AgentAudioEvent,\n  AgentChatResponsePartEvent,\n  AgentResponseEvent,\n  ClientToolCallEvent,\n  IncomingSocketEvent,\n  InternalTentativeAgentResponseEvent,\n  InterruptionEvent,\n  UserTranscriptionEvent,\n  VadScoreEvent,\n  MCPToolCallClientEvent,\n  AgentToolResponseEvent,\n  ConversationMetadataEvent,\n  AsrInitiationMetadataEvent,\n  MCPConnectionStatusEvent,\n  ErrorMessageEvent,\n  AgentToolRequestEvent,\n} from \"./utils/events\";\nimport type { InputConfig } from \"./utils/input\";\nimport type { OutputConfig } from \"./utils/output\";\n\nexport type { Role, Mode, Status, Callbacks } from \"@elevenlabs/types\";\n\n/** Allows self-hosting the worklets to avoid whitelisting blob: and data: in the CSP script-src  */\nexport type AudioWorkletConfig = {\n  workletPaths?: {\n    rawAudioProcessor?: string;\n    audioConcatProcessor?: string;\n  };\n  libsampleratePath?: string;\n};\n\nexport type Options = SessionConfig &\n  Callbacks &\n  ClientToolsConfig &\n  InputConfig &\n  OutputConfig &\n  AudioWorkletConfig;\n\nexport type PartialOptions = SessionConfig &\n  Partial<Callbacks> &\n  Partial<ClientToolsConfig> &\n  Partial<InputConfig> &\n  Partial<OutputConfig> &\n  Partial<FormatConfig> &\n  Partial<AudioWorkletConfig>;\n\nexport type ClientToolsConfig = {\n  clientTools: Record<\n    string,\n    (\n      parameters: any\n    ) => Promise<string | number | void> | string | number | void\n  >;\n};\n\nconst EMPTY_FREQUENCY_DATA = new Uint8Array(0);\n\nexport function isTextOnly(options: PartialOptions): boolean | undefined {\n  const { textOnly: textOnlyOverride } = options.overrides?.conversation ?? {};\n  const { textOnly } = options;\n  if (typeof textOnly === \"boolean\") {\n    if (\n      typeof textOnlyOverride === \"boolean\" &&\n      textOnly !== textOnlyOverride\n    ) {\n      console.warn(\n        `Conflicting textOnly options provided: ${textOnly} via options.textOnly (will be used) and ${textOnlyOverride} via options.overrides.conversation.textOnly (will be ignored)`\n      );\n    }\n    return textOnly;\n  } else if (typeof textOnlyOverride === \"boolean\") {\n    return textOnlyOverride;\n  } else {\n    return undefined;\n  }\n}\n\nexport class BaseConversation {\n  protected lastInterruptTimestamp = 0;\n  protected mode: Mode = \"listening\";\n  protected status: Status = \"connecting\";\n  protected volume = 1;\n  protected currentEventId = 1;\n  protected lastFeedbackEventId = 0;\n  protected canSendFeedback = false;\n\n  protected static getFullOptions(partialOptions: PartialOptions): Options {\n    const textOnly = isTextOnly(partialOptions);\n    return {\n      clientTools: {},\n      onConnect: () => {},\n      onDebug: () => {},\n      onDisconnect: () => {},\n      onError: () => {},\n      onMessage: () => {},\n      onAudio: () => {},\n      onModeChange: () => {},\n      onStatusChange: () => {},\n      onCanSendFeedbackChange: () => {},\n      onInterruption: () => {},\n      ...partialOptions,\n      textOnly,\n      overrides: {\n        ...partialOptions.overrides,\n        conversation: {\n          ...partialOptions.overrides?.conversation,\n          textOnly,\n        },\n      },\n    };\n  }\n\n  protected constructor(\n    protected readonly options: Options,\n    protected readonly connection: BaseConnection\n  ) {\n    if (this.options.onConnect) {\n      this.options.onConnect({ conversationId: connection.conversationId });\n    }\n    this.connection.onMessage(this.onMessage);\n    this.connection.onDisconnect(this.endSessionWithDetails);\n    this.connection.onModeChange(mode => this.updateMode(mode));\n    this.updateStatus(\"connected\");\n  }\n\n  public endSession() {\n    return this.endSessionWithDetails({ reason: \"user\" });\n  }\n\n  private endSessionWithDetails = async (details: DisconnectionDetails) => {\n    if (this.status !== \"connected\" && this.status !== \"connecting\") return;\n    this.updateStatus(\"disconnecting\");\n    await this.handleEndSession();\n    this.updateStatus(\"disconnected\");\n    if (this.options.onDisconnect) {\n      this.options.onDisconnect(details);\n    }\n  };\n\n  protected async handleEndSession() {\n    this.connection.close();\n  }\n\n  protected updateMode(mode: Mode) {\n    if (mode !== this.mode) {\n      this.mode = mode;\n      if (this.options.onModeChange) {\n        this.options.onModeChange({ mode });\n      }\n    }\n  }\n\n  protected updateStatus(status: Status) {\n    if (status !== this.status) {\n      this.status = status;\n      if (this.options.onStatusChange) {\n        this.options.onStatusChange({ status });\n      }\n    }\n  }\n\n  protected updateCanSendFeedback() {\n    const canSendFeedback = this.currentEventId !== this.lastFeedbackEventId;\n    if (this.canSendFeedback !== canSendFeedback) {\n      this.canSendFeedback = canSendFeedback;\n      if (this.options.onCanSendFeedbackChange) {\n        this.options.onCanSendFeedbackChange({ canSendFeedback });\n      }\n    }\n  }\n\n  protected handleInterruption(event: InterruptionEvent) {\n    if (event.interruption_event) {\n      this.lastInterruptTimestamp = event.interruption_event.event_id;\n\n      if (this.options.onInterruption) {\n        this.options.onInterruption({\n          event_id: event.interruption_event.event_id,\n        });\n      }\n    }\n  }\n\n  protected handleAgentResponse(event: AgentResponseEvent) {\n    if (this.options.onMessage) {\n      this.options.onMessage({\n        source: \"ai\",\n        role: \"agent\",\n        message: event.agent_response_event.agent_response,\n      });\n    }\n  }\n\n  protected handleUserTranscript(event: UserTranscriptionEvent) {\n    if (this.options.onMessage) {\n      this.options.onMessage({\n        source: \"user\",\n        role: \"user\",\n        message: event.user_transcription_event.user_transcript,\n      });\n    }\n  }\n\n  protected handleTentativeAgentResponse(\n    event: InternalTentativeAgentResponseEvent\n  ) {\n    if (this.options.onDebug) {\n      this.options.onDebug({\n        type: \"tentative_agent_response\",\n        response:\n          event.tentative_agent_response_internal_event\n            .tentative_agent_response,\n      });\n    }\n  }\n\n  protected handleVadScore(event: VadScoreEvent) {\n    if (this.options.onVadScore) {\n      this.options.onVadScore({\n        vadScore: event.vad_score_event.vad_score,\n      });\n    }\n  }\n\n  protected async handleClientToolCall(event: ClientToolCallEvent) {\n    if (\n      Object.prototype.hasOwnProperty.call(\n        this.options.clientTools,\n        event.client_tool_call.tool_name\n      )\n    ) {\n      try {\n        const result =\n          (await this.options.clientTools[event.client_tool_call.tool_name](\n            event.client_tool_call.parameters\n          )) ?? \"Client tool execution successful.\"; // default client-tool call response\n\n        // The API expects result to be a string, so we need to convert it if it's not already a string\n        const formattedResult =\n          typeof result === \"object\" ? JSON.stringify(result) : String(result);\n\n        this.connection.sendMessage({\n          type: \"client_tool_result\",\n          tool_call_id: event.client_tool_call.tool_call_id,\n          result: formattedResult,\n          is_error: false,\n        });\n      } catch (e) {\n        this.onError(\n          `Client tool execution failed with following error: ${(e as Error)?.message}`,\n          {\n            clientToolName: event.client_tool_call.tool_name,\n          }\n        );\n        this.connection.sendMessage({\n          type: \"client_tool_result\",\n          tool_call_id: event.client_tool_call.tool_call_id,\n          result: `Client tool execution failed: ${(e as Error)?.message}`,\n          is_error: true,\n        });\n      }\n    } else {\n      if (this.options.onUnhandledClientToolCall) {\n        this.options.onUnhandledClientToolCall(event.client_tool_call);\n\n        return;\n      }\n\n      this.onError(\n        `Client tool with name ${event.client_tool_call.tool_name} is not defined on client`,\n        {\n          clientToolName: event.client_tool_call.tool_name,\n        }\n      );\n      this.connection.sendMessage({\n        type: \"client_tool_result\",\n        tool_call_id: event.client_tool_call.tool_call_id,\n        result: `Client tool with name ${event.client_tool_call.tool_name} is not defined on client`,\n        is_error: true,\n      });\n    }\n  }\n\n  protected handleAudio(event: AgentAudioEvent) {}\n\n  protected handleMCPToolCall(event: MCPToolCallClientEvent) {\n    if (this.options.onMCPToolCall) {\n      this.options.onMCPToolCall(event.mcp_tool_call);\n    }\n  }\n\n  protected handleMCPConnectionStatus(event: MCPConnectionStatusEvent) {\n    if (this.options.onMCPConnectionStatus) {\n      this.options.onMCPConnectionStatus(event.mcp_connection_status);\n    }\n  }\n\n  protected handleAgentToolRequest(event: AgentToolRequestEvent) {\n    if (this.options.onAgentToolRequest) {\n      this.options.onAgentToolRequest(event.agent_tool_request);\n    }\n  }\n\n  protected handleAgentToolResponse(event: AgentToolResponseEvent) {\n    if (event.agent_tool_response.tool_name === \"end_call\") {\n      this.endSessionWithDetails({\n        reason: \"agent\",\n        context: new CloseEvent(\"end_call\", { reason: \"Agent ended the call\" }),\n      });\n    }\n\n    if (this.options.onAgentToolResponse) {\n      this.options.onAgentToolResponse(event.agent_tool_response);\n    }\n  }\n\n  protected handleConversationMetadata(event: ConversationMetadataEvent) {\n    if (this.options.onConversationMetadata) {\n      this.options.onConversationMetadata(\n        event.conversation_initiation_metadata_event\n      );\n    }\n  }\n\n  protected handleAsrInitiationMetadata(event: AsrInitiationMetadataEvent) {\n    if (this.options.onAsrInitiationMetadata) {\n      this.options.onAsrInitiationMetadata(event.asr_initiation_metadata_event);\n    }\n  }\n\n  protected handleAgentChatResponsePart(event: AgentChatResponsePartEvent) {\n    if (this.options.onAgentChatResponsePart) {\n      this.options.onAgentChatResponsePart(event.text_response_part);\n    }\n  }\n\n  protected handleErrorEvent(event: ErrorMessageEvent) {\n    const errorType = event.error_event.error_type;\n    const message =\n      event.error_event.message || event.error_event.reason || \"Unknown error\";\n\n    if (errorType === \"max_duration_exceeded\") {\n      this.endSessionWithDetails({\n        reason: \"error\",\n        message: message,\n        context: new Event(\"max_duration_exceeded\"),\n      });\n      return;\n    }\n\n    this.onError(`Server error: ${message}`, {\n      errorType,\n      code: event.error_event.code,\n      debugMessage: event.error_event.debug_message,\n      details: event.error_event.details,\n    });\n  }\n\n  private onMessage = async (parsedEvent: IncomingSocketEvent) => {\n    switch (parsedEvent.type) {\n      case \"interruption\": {\n        this.handleInterruption(parsedEvent);\n        return;\n      }\n      case \"agent_response\": {\n        this.handleAgentResponse(parsedEvent);\n        return;\n      }\n      case \"user_transcript\": {\n        this.handleUserTranscript(parsedEvent);\n        return;\n      }\n      case \"internal_tentative_agent_response\": {\n        this.handleTentativeAgentResponse(parsedEvent);\n        return;\n      }\n      case \"client_tool_call\": {\n        try {\n          await this.handleClientToolCall(parsedEvent);\n        } catch (error) {\n          this.onError(\n            `Unexpected error in client tool call handling: ${error instanceof Error ? error.message : String(error)}`,\n            {\n              clientToolName: parsedEvent.client_tool_call.tool_name,\n              toolCallId: parsedEvent.client_tool_call.tool_call_id,\n            }\n          );\n        }\n        return;\n      }\n      case \"audio\": {\n        this.handleAudio(parsedEvent);\n        return;\n      }\n\n      case \"vad_score\": {\n        this.handleVadScore(parsedEvent);\n        return;\n      }\n\n      case \"ping\": {\n        this.connection.sendMessage({\n          type: \"pong\",\n          event_id: parsedEvent.ping_event.event_id,\n        });\n        // parsedEvent.ping_event.ping_ms can be used on client side, for example\n        // to warn if ping is too high that experience might be degraded.\n        return;\n      }\n\n      case \"mcp_tool_call\": {\n        this.handleMCPToolCall(parsedEvent);\n        return;\n      }\n\n      case \"mcp_connection_status\": {\n        this.handleMCPConnectionStatus(parsedEvent);\n        return;\n      }\n\n      case \"agent_tool_request\": {\n        this.handleAgentToolRequest(parsedEvent);\n        return;\n      }\n\n      case \"agent_tool_response\": {\n        this.handleAgentToolResponse(parsedEvent);\n        return;\n      }\n\n      case \"conversation_initiation_metadata\": {\n        this.handleConversationMetadata(parsedEvent);\n        return;\n      }\n\n      case \"asr_initiation_metadata\": {\n        this.handleAsrInitiationMetadata(parsedEvent);\n        return;\n      }\n\n      case \"agent_chat_response_part\": {\n        this.handleAgentChatResponsePart(parsedEvent);\n        return;\n      }\n\n      case \"error\": {\n        this.handleErrorEvent(parsedEvent);\n        return;\n      }\n\n      default: {\n        if (this.options.onDebug) {\n          this.options.onDebug(parsedEvent);\n        }\n        return;\n      }\n    }\n  };\n\n  private onError(message: string, context?: any) {\n    console.error(message, context);\n    if (this.options.onError) {\n      this.options.onError(message, context);\n    }\n  }\n\n  public getId() {\n    return this.connection.conversationId;\n  }\n\n  public isOpen() {\n    return this.status === \"connected\";\n  }\n\n  public setVolume = ({ volume }: { volume: number }) => {\n    this.volume = volume;\n  };\n\n  public setMicMuted(isMuted: boolean) {\n    this.connection.setMicMuted(isMuted);\n  }\n\n  public getInputByteFrequencyData(): Uint8Array {\n    return EMPTY_FREQUENCY_DATA;\n  }\n\n  public getOutputByteFrequencyData(): Uint8Array {\n    return EMPTY_FREQUENCY_DATA;\n  }\n\n  public getInputVolume() {\n    return 0;\n  }\n\n  public getOutputVolume() {\n    return 0;\n  }\n\n  public sendFeedback(like: boolean) {\n    if (!this.canSendFeedback) {\n      console.warn(\n        this.lastFeedbackEventId === 0\n          ? \"Cannot send feedback: the conversation has not started yet.\"\n          : \"Cannot send feedback: feedback has already been sent for the current response.\"\n      );\n      return;\n    }\n\n    this.connection.sendMessage({\n      type: \"feedback\",\n      score: like ? \"like\" : \"dislike\",\n      event_id: this.currentEventId,\n    });\n    this.lastFeedbackEventId = this.currentEventId;\n    this.updateCanSendFeedback();\n  }\n\n  public sendContextualUpdate(text: string) {\n    this.connection.sendMessage({\n      type: \"contextual_update\",\n      text,\n    });\n  }\n\n  public sendUserMessage(text: string) {\n    this.connection.sendMessage({\n      type: \"user_message\",\n      text,\n    });\n  }\n\n  public sendUserActivity() {\n    this.connection.sendMessage({\n      type: \"user_activity\",\n    });\n  }\n\n  public sendMCPToolApprovalResult(toolCallId: string, isApproved: boolean) {\n    this.connection.sendMessage({\n      type: \"mcp_tool_approval_result\",\n      tool_call_id: toolCallId,\n      is_approved: isApproved,\n    });\n  }\n}\n","import type { IncomingSocketEvent, OutgoingSocketEvent } from \"./events\";\nimport type { Mode } from \"../BaseConversation\";\nimport type { ConversationConfigOverrideAgentLanguage as Language } from \"@elevenlabs/types/generated/types/asyncapi-types\";\nimport type { DisconnectionDetails } from \"@elevenlabs/types\";\n\nexport type {\n  DisconnectionDetails,\n  ConversationConfigOverrideAgentLanguage as Language,\n} from \"@elevenlabs/types\";\n\nexport type DelayConfig = {\n  default: number;\n  android?: number;\n  ios?: number;\n};\n\nexport type FormatConfig = {\n  format: \"pcm\" | \"ulaw\";\n  sampleRate: number;\n  outputDeviceId?: string;\n};\n\nexport type OnDisconnectCallback = (details: DisconnectionDetails) => void;\nexport type OnMessageCallback = (event: IncomingSocketEvent) => void;\n\nexport type BaseSessionConfig = {\n  origin?: string;\n  authorization?: string;\n  livekitUrl?: string;\n  overrides?: {\n    agent?: {\n      prompt?: {\n        prompt?: string;\n      };\n      firstMessage?: string;\n      language?: Language;\n    };\n    tts?: {\n      voiceId?: string;\n      speed?: number;\n      stability?: number;\n      similarityBoost?: number;\n    };\n    conversation?: {\n      textOnly?: boolean;\n    };\n    client?: {\n      source?: string;\n      version?: string;\n    };\n  };\n  customLlmExtraBody?: unknown;\n  dynamicVariables?: Record<string, string | number | boolean>;\n  useWakeLock?: boolean;\n  connectionDelay?: DelayConfig;\n  textOnly?: boolean;\n  userId?: string;\n};\n\nexport type ConnectionType = \"websocket\" | \"webrtc\";\n\nexport type PublicSessionConfig = BaseSessionConfig & {\n  agentId: string;\n  connectionType: ConnectionType;\n  signedUrl?: never;\n  conversationToken?: never;\n};\n\nexport type PrivateWebSocketSessionConfig = BaseSessionConfig & {\n  signedUrl: string;\n  connectionType?: \"websocket\";\n  agentId?: never;\n  conversationToken?: never;\n};\n\nexport type PrivateWebRTCSessionConfig = BaseSessionConfig & {\n  conversationToken: string;\n  connectionType?: \"webrtc\";\n  agentId?: never;\n  signedUrl?: never;\n};\n\n// Union type for all possible session configurations\nexport type SessionConfig =\n  | PublicSessionConfig\n  | PrivateWebSocketSessionConfig\n  | PrivateWebRTCSessionConfig;\n\nexport abstract class BaseConnection {\n  public abstract readonly conversationId: string;\n  public abstract readonly inputFormat: FormatConfig;\n  public abstract readonly outputFormat: FormatConfig;\n\n  protected queue: IncomingSocketEvent[] = [];\n  protected disconnectionDetails: DisconnectionDetails | null = null;\n  protected onDisconnectCallback: OnDisconnectCallback | null = null;\n  protected onMessageCallback: OnMessageCallback | null = null;\n  protected onModeChangeCallback: ((mode: Mode) => void) | null = null;\n  protected onDebug?: (info: unknown) => void;\n\n  constructor(config: { onDebug?: (info: unknown) => void } = {}) {\n    this.onDebug = config.onDebug;\n  }\n\n  protected debug(info: unknown) {\n    if (this.onDebug) this.onDebug(info);\n  }\n\n  public abstract close(): void;\n  public abstract sendMessage(message: OutgoingSocketEvent): void;\n  public abstract setMicMuted(isMuted: boolean): Promise<void>;\n\n  public onMessage(callback: OnMessageCallback) {\n    this.onMessageCallback = callback;\n    const queue = this.queue;\n    this.queue = [];\n\n    if (queue.length > 0) {\n      // Make sure the queue is flushed after the constructors finishes and\n      // classes are initialized.\n      queueMicrotask(() => {\n        queue.forEach(callback);\n      });\n    }\n  }\n\n  public onDisconnect(callback: OnDisconnectCallback) {\n    this.onDisconnectCallback = callback;\n    const details = this.disconnectionDetails;\n    if (details) {\n      // Make sure the event is triggered after the constructors finishes and\n      // classes are initialized.\n      queueMicrotask(() => {\n        callback(details);\n      });\n    }\n  }\n\n  public onModeChange(callback: (mode: Mode) => void) {\n    this.onModeChangeCallback = callback;\n  }\n\n  protected updateMode(mode: Mode) {\n    this.onModeChangeCallback?.(mode);\n  }\n\n  protected disconnect(details: DisconnectionDetails) {\n    if (!this.disconnectionDetails) {\n      this.disconnectionDetails = details;\n      this.onDisconnectCallback?.(details);\n    }\n  }\n\n  protected handleMessage(parsedEvent: IncomingSocketEvent) {\n    if (this.onMessageCallback) {\n      this.onMessageCallback(parsedEvent);\n    } else {\n      this.queue.push(parsedEvent);\n    }\n  }\n}\n\nexport function parseFormat(format: string): FormatConfig {\n  const [formatPart, sampleRatePart] = format.split(\"_\");\n  if (![\"pcm\", \"ulaw\"].includes(formatPart)) {\n    throw new Error(`Invalid format: ${format}`);\n  }\n\n  const sampleRate = Number.parseInt(sampleRatePart);\n  if (Number.isNaN(sampleRate)) {\n    throw new Error(`Invalid sample rate: ${sampleRatePart}`);\n  }\n\n  return {\n    format: formatPart as FormatConfig[\"format\"],\n    sampleRate,\n  };\n}\n","// This file is auto-generated during build\nexport const PACKAGE_VERSION = \"0.14.0\";\n","import { Outgoing } from \"@elevenlabs/types\";\nimport type { AudioAlignmentEvent } from \"@elevenlabs/types\";\nimport {\n  AgentChatResponsePartClientEvent,\n  AgentResponse,\n  AgentResponseCorrection,\n  AgentToolResponseClientEvent,\n  AsrInitiationMetadataEvent as AsrMetadataEvent,\n  Audio,\n  AgentToolRequestClientEvent,\n  ClientToolCallMessage,\n  ConversationMetadata,\n  ErrorMessage,\n  Interruption,\n  McpConnectionStatusClientEvent,\n  McpToolCall,\n  Ping,\n  InternalTentativeAgentResponse as TentativeAgentResponseInternal,\n  UserTranscript,\n  VadScore,\n} from \"@elevenlabs/types/generated/types/asyncapi-types\";\n\n// Compatibility layer - incoming events\nexport type UserTranscriptionEvent = UserTranscript;\nexport type AgentResponseEvent = AgentResponse;\nexport type AgentAudioEvent = Audio;\nexport type InterruptionEvent = Interruption;\nexport type InternalTentativeAgentResponseEvent =\n  TentativeAgentResponseInternal;\nexport type ConfigEvent = ConversationMetadata;\nexport type PingEvent = Ping;\nexport type ClientToolCallEvent = ClientToolCallMessage;\nexport type VadScoreEvent = VadScore;\nexport type MCPToolCallClientEvent = McpToolCall;\nexport type AgentResponseCorrectionEvent = AgentResponseCorrection;\nexport type AgentToolRequestEvent = AgentToolRequestClientEvent;\nexport type AgentToolResponseEvent = AgentToolResponseClientEvent;\nexport type ConversationMetadataEvent = ConversationMetadata;\nexport type AsrInitiationMetadataEvent = AsrMetadataEvent;\nexport type MCPConnectionStatusEvent = McpConnectionStatusClientEvent;\nexport type AgentChatResponsePartEvent = AgentChatResponsePartClientEvent;\nexport type ErrorMessageEvent = ErrorMessage;\nexport type { AudioAlignmentEvent };\n\nexport type IncomingSocketEvent =\n  | UserTranscriptionEvent\n  | AgentResponseEvent\n  | AgentResponseCorrectionEvent\n  | AgentAudioEvent\n  | InterruptionEvent\n  | InternalTentativeAgentResponseEvent\n  | ConfigEvent\n  | PingEvent\n  | ClientToolCallEvent\n  | VadScoreEvent\n  | MCPToolCallClientEvent\n  | AgentToolRequestEvent\n  | AgentToolResponseEvent\n  | ConversationMetadataEvent\n  | AsrInitiationMetadataEvent\n  | MCPConnectionStatusEvent\n  | AgentChatResponsePartEvent\n  | ErrorMessageEvent;\n\n// Compatibility layer - outgoing events\nexport type PongEvent = Outgoing.PongClientToOrchestratorEvent;\nexport type UserAudioEvent = Outgoing.UserAudio;\nexport type UserFeedbackEvent = Outgoing.UserFeedbackClientToOrchestratorEvent;\nexport type ClientToolResultEvent =\n  Outgoing.ClientToolResultClientToOrchestratorEvent;\nexport type InitiationClientDataEvent =\n  Outgoing.ConversationInitiationClientToOrchestratorEvent;\nexport type ContextualUpdateEvent =\n  Outgoing.ContextualUpdateClientToOrchestratorEvent;\nexport type UserMessageEvent = Outgoing.UserMessageClientToOrchestratorEvent;\nexport type UserActivityEvent = Outgoing.UserActivityClientToOrchestratorEvent;\nexport type MCPToolApprovalResultEvent =\n  Outgoing.McpToolApprovalResultClientToOrchestratorEvent;\n\nexport type OutgoingSocketEvent =\n  | PongEvent\n  | UserAudioEvent\n  | InitiationClientDataEvent\n  | UserFeedbackEvent\n  | ClientToolResultEvent\n  | ContextualUpdateEvent\n  | UserMessageEvent\n  | UserActivityEvent\n  | MCPToolApprovalResultEvent;\n\nexport function isValidSocketEvent(event: any): event is IncomingSocketEvent {\n  return !!event.type;\n}\n","import type { SessionConfig } from \"./BaseConnection\";\nimport type { InitiationClientDataEvent } from \"./events\";\n\nexport const CONVERSATION_INITIATION_CLIENT_DATA_TYPE =\n  \"conversation_initiation_client_data\";\n\nexport function constructOverrides(\n  config: SessionConfig\n): InitiationClientDataEvent {\n  const overridesEvent: InitiationClientDataEvent = {\n    type: CONVERSATION_INITIATION_CLIENT_DATA_TYPE,\n  };\n\n  if (config.overrides) {\n    overridesEvent.conversation_config_override = {\n      agent: {\n        prompt: config.overrides.agent?.prompt,\n        first_message: config.overrides.agent?.firstMessage,\n        language: config.overrides.agent?.language,\n      },\n      tts: {\n        voice_id: config.overrides.tts?.voiceId,\n        speed: config.overrides.tts?.speed,\n        stability: config.overrides.tts?.stability,\n        similarity_boost: config.overrides.tts?.similarityBoost,\n      },\n      conversation: {\n        text_only: config.overrides.conversation?.textOnly,\n      },\n    };\n  }\n\n  if (config.customLlmExtraBody) {\n    overridesEvent.custom_llm_extra_body = config.customLlmExtraBody;\n  }\n\n  if (config.dynamicVariables) {\n    overridesEvent.dynamic_variables = config.dynamicVariables;\n  }\n\n  if (config.userId) {\n    overridesEvent.user_id = config.userId;\n  }\n\n  if (config.overrides?.client) {\n    overridesEvent.source_info = {\n      source: config.overrides.client.source,\n      version: config.overrides.client.version,\n    };\n  }\n\n  return overridesEvent;\n}\n","export class SessionConnectionError extends Error {\n  public readonly closeCode?: number;\n  public readonly closeReason?: string;\n\n  constructor(\n    message: string,\n    options?: { closeCode?: number; closeReason?: string }\n  ) {\n    super(message);\n    this.name = \"SessionConnectionError\";\n    this.closeCode = options?.closeCode;\n    this.closeReason = options?.closeReason;\n  }\n}\n","import {\n  BaseConnection,\n  type SessionConfig,\n  type FormatConfig,\n  parseFormat,\n} from \"./BaseConnection\";\nimport { PACKAGE_VERSION } from \"../version\";\nimport {\n  type ConfigEvent,\n  isValidSocketEvent,\n  type OutgoingSocketEvent,\n} from \"./events\";\nimport { constructOverrides } from \"./overrides\";\nimport { SessionConnectionError } from \"./errors\";\n\nconst MAIN_PROTOCOL = \"convai\";\nconst WSS_API_ORIGIN = \"wss://api.elevenlabs.io\";\nconst WSS_API_PATHNAME = \"/v1/convai/conversation?agent_id=\";\n\nexport class WebSocketConnection extends BaseConnection {\n  public readonly conversationId: string;\n  public readonly inputFormat: FormatConfig;\n  public readonly outputFormat: FormatConfig;\n\n  private constructor(\n    private readonly socket: WebSocket,\n    conversationId: string,\n    inputFormat: FormatConfig,\n    outputFormat: FormatConfig\n  ) {\n    super();\n    this.conversationId = conversationId;\n    this.inputFormat = inputFormat;\n    this.outputFormat = outputFormat;\n\n    this.socket.addEventListener(\"error\", event => {\n      // In case the error event is followed by a close event, we want the\n      // latter to be the one that disconnects the session as it contains more\n      // useful information.\n      setTimeout(\n        () =>\n          this.disconnect({\n            reason: \"error\",\n            message: \"The connection was closed due to a socket error.\",\n            context: event,\n          }),\n        0\n      );\n    });\n\n    this.socket.addEventListener(\"close\", event => {\n      this.disconnect(\n        event.code === 1000\n          ? {\n              reason: \"agent\",\n              context: event,\n              closeCode: event.code,\n              closeReason: event.reason || undefined,\n            }\n          : {\n              reason: \"error\",\n              message:\n                event.reason || \"The connection was closed by the server.\",\n              context: event,\n              closeCode: event.code,\n              closeReason: event.reason || undefined,\n            }\n      );\n    });\n\n    this.socket.addEventListener(\"message\", event => {\n      try {\n        const parsedEvent = JSON.parse(event.data);\n        if (!isValidSocketEvent(parsedEvent)) {\n          this.debug({\n            type: \"invalid_event\",\n            message: \"Received invalid socket event\",\n            data: event.data,\n          });\n          return;\n        }\n        this.handleMessage(parsedEvent);\n      } catch (error) {\n        this.debug({\n          type: \"parsing_error\",\n          message: \"Failed to parse socket message\",\n          error: error instanceof Error ? error.message : String(error),\n          data: event.data,\n        });\n      }\n    });\n  }\n\n  public static async create(\n    config: SessionConfig\n  ): Promise<WebSocketConnection> {\n    let socket: WebSocket | null = null;\n\n    try {\n      const origin = config.origin ?? WSS_API_ORIGIN;\n      let url: string;\n\n      const version = config.overrides?.client?.version || PACKAGE_VERSION;\n      const source = config.overrides?.client?.source || \"js_sdk\";\n\n      if (config.signedUrl) {\n        const separator = config.signedUrl.includes(\"?\") ? \"&\" : \"?\";\n        url = `${config.signedUrl}${separator}source=${source}&version=${version}`;\n      } else {\n        url = `${origin}${WSS_API_PATHNAME}${config.agentId}&source=${source}&version=${version}`;\n      }\n\n      const protocols = [MAIN_PROTOCOL];\n      if (config.authorization) {\n        protocols.push(`bearer.${config.authorization}`);\n      }\n      socket = new WebSocket(url, protocols);\n\n      const conversationConfig = await new Promise<\n        ConfigEvent[\"conversation_initiation_metadata_event\"]\n      >((resolve, reject) => {\n        socket!.addEventListener(\n          \"open\",\n          () => {\n            const overridesEvent = constructOverrides(config);\n\n            socket?.send(JSON.stringify(overridesEvent));\n          },\n          { once: true }\n        );\n\n        socket!.addEventListener(\"error\", event => {\n          // In case the error event is followed by a close event, we want the\n          // latter to be the one that rejects the promise as it contains more\n          // useful information.\n          setTimeout(\n            () =>\n              reject(\n                new SessionConnectionError(\n                  \"The connection was closed due to a socket error.\"\n                )\n              ),\n            0\n          );\n        });\n\n        socket!.addEventListener(\"close\", (event: CloseEvent) => {\n          const message =\n            event.reason ||\n            (event.code === 1000\n              ? \"Connection closed normally before session could be established.\"\n              : \"Connection closed unexpectedly before session could be established.\");\n          reject(\n            new SessionConnectionError(message, {\n              closeCode: event.code,\n              closeReason: event.reason || undefined,\n            })\n          );\n        });\n\n        socket!.addEventListener(\n          \"message\",\n          (event: MessageEvent) => {\n            const message = JSON.parse(event.data);\n\n            if (!isValidSocketEvent(message)) {\n              return;\n            }\n\n            if (message.type === \"conversation_initiation_metadata\") {\n              resolve(message.conversation_initiation_metadata_event);\n            } else {\n              console.warn(\n                \"First received message is not conversation metadata.\"\n              );\n            }\n          },\n          { once: true }\n        );\n      });\n\n      const {\n        conversation_id,\n        agent_output_audio_format,\n        user_input_audio_format,\n      } = conversationConfig;\n\n      const inputFormat = parseFormat(user_input_audio_format ?? \"pcm_16000\");\n      const outputFormat = parseFormat(agent_output_audio_format);\n\n      return new WebSocketConnection(\n        socket,\n        conversation_id,\n        inputFormat,\n        outputFormat\n      );\n    } catch (error) {\n      socket?.close();\n      throw error;\n    }\n  }\n\n  public close() {\n    this.socket.close(1000, \"User ended conversation\");\n  }\n\n  public sendMessage(message: OutgoingSocketEvent) {\n    this.socket.send(JSON.stringify(message));\n  }\n\n  public async setMicMuted(isMuted: boolean): Promise<void> {\n    console.warn(\n      `WebSocket connection setMicMuted called with ${isMuted}, but this is handled by VoiceConversation`\n    );\n  }\n}\n","export function arrayBufferToBase64(b: ArrayBufferLike) {\n  const buffer = new Uint8Array(b);\n  // @ts-ignore\n  const base64Data = window.btoa(String.fromCharCode(...buffer));\n  return base64Data;\n}\n\nexport function base64ToArrayBuffer(base64: string): ArrayBuffer {\n  const binaryString = window.atob(base64);\n  const len = binaryString.length;\n  const bytes = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return bytes.buffer;\n}\n","const URLCache = new Map<string, string>();\n\nexport function createWorkletModuleLoader(name: string, sourceCode: string) {\n  return async (worklet: AudioWorklet, path?: string) => {\n    const cachedUrl = URLCache.get(name);\n    if (cachedUrl) {\n      return worklet.addModule(cachedUrl);\n    }\n\n    // If a path is provided, use it directly (CSP-friendly approach)\n    if (path) {\n      try {\n        await worklet.addModule(path);\n        URLCache.set(name, path);\n        return;\n      } catch (error) {\n        throw new Error(\n          `Failed to load the ${name} worklet module from path: ${path}. Error: ${error}`\n        );\n      }\n    }\n\n    const blob = new Blob([sourceCode], { type: \"application/javascript\" });\n    const blobURL = URL.createObjectURL(blob);\n    try {\n      await worklet.addModule(blobURL);\n      URLCache.set(name, blobURL);\n      return;\n    } catch {\n      URL.revokeObjectURL(blobURL);\n    }\n\n    try {\n      // Attempting to start a conversation in Safari inside an iframe will\n      // throw a CORS error because the blob:// protocol is considered\n      // cross-origin. In such cases, fall back to using a base64 data URL:\n      const base64 = btoa(sourceCode);\n      const moduleURL = `data:application/javascript;base64,${base64}`;\n      await worklet.addModule(moduleURL);\n      URLCache.set(name, moduleURL);\n    } catch (error) {\n      throw new Error(\n        `Failed to load the ${name} worklet module. Make sure the browser supports AudioWorklets. If you are using a strict CSP, you may need to self-host the worklet files.`\n      );\n    }\n  };\n}\n","// AUTO-GENERATED BY packages/client/scripts/generateWorklets.js\nimport { createWorkletModuleLoader } from \"./createWorkletModuleLoader\";\n\nexport const loadRawAudioProcessor = createWorkletModuleLoader(\n  \"rawAudioProcessor\",\n  // language=JavaScript\n  `/*\n * ulaw encoding logic taken from the wavefile library\n * https://github.com/rochars/wavefile/blob/master/lib/codecs/mulaw.js\n * USED BY @elevenlabs/client\n */\n\nconst BIAS = 0x84;\nconst CLIP = 32635;\nconst encodeTable = [\n  0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,\n  4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,\n  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7\n];\n\nfunction encodeSample(sample) {\n  let sign;\n  let exponent;\n  let mantissa;\n  let muLawSample;\n  sign = (sample >> 8) & 0x80;\n  if (sign !== 0) sample = -sample;\n  sample = sample + BIAS;\n  if (sample > CLIP) sample = CLIP;\n  exponent = encodeTable[(sample>>7) & 0xFF];\n  mantissa = (sample >> (exponent+3)) & 0x0F;\n  muLawSample = ~(sign | (exponent << 4) | mantissa);\n  \n  return muLawSample;\n}\n\nclass RawAudioProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n              \n    this.port.onmessage = ({ data }) => {\n      switch (data.type) {\n        case \"setFormat\":\n          this.isMuted = false;\n          this.buffer = []; // Initialize an empty buffer\n          this.bufferSize = data.sampleRate / 10;\n          this.format = data.format;\n\n          if (globalThis.LibSampleRate && sampleRate !== data.sampleRate) {\n            globalThis.LibSampleRate.create(1, sampleRate, data.sampleRate).then(resampler => {\n              this.resampler = resampler;\n            });\n          }\n          break;\n        case \"setMuted\":\n          this.isMuted = data.isMuted;\n          break;\n      }\n    };\n  }\n  process(inputs) {\n    if (!this.buffer) {\n      return true;\n    }\n    \n    const input = inputs[0]; // Get the first input node\n    if (input.length > 0) {\n      let channelData = input[0]; // Get the first channel's data\n\n      // Resample the audio if necessary\n      if (this.resampler) {\n        channelData = this.resampler.full(channelData);\n      }\n\n      // Add channel data to the buffer\n      this.buffer.push(...channelData);\n      // Get max volume \n      let sum = 0.0;\n      for (let i = 0; i < channelData.length; i++) {\n        sum += channelData[i] * channelData[i];\n      }\n      const maxVolume = Math.sqrt(sum / channelData.length);\n      // Check if buffer size has reached or exceeded the threshold\n      if (this.buffer.length >= this.bufferSize) {\n        const float32Array = this.isMuted \n          ? new Float32Array(this.buffer.length)\n          : new Float32Array(this.buffer);\n\n        let encodedArray = this.format === \"ulaw\"\n          ? new Uint8Array(float32Array.length)\n          : new Int16Array(float32Array.length);\n\n        // Iterate through the Float32Array and convert each sample to PCM16\n        for (let i = 0; i < float32Array.length; i++) {\n          // Clamp the value to the range [-1, 1]\n          let sample = Math.max(-1, Math.min(1, float32Array[i]));\n\n          // Scale the sample to the range [-32768, 32767]\n          let value = sample < 0 ? sample * 32768 : sample * 32767;\n          if (this.format === \"ulaw\") {\n            value = encodeSample(Math.round(value));\n          }\n\n          encodedArray[i] = value;\n        }\n\n        // Send the buffered data to the main script\n        this.port.postMessage([encodedArray, maxVolume]);\n\n        // Clear the buffer after sending\n        this.buffer = [];\n      }\n    }\n    return true; // Continue processing\n  }\n}\nregisterProcessor(\"rawAudioProcessor\", RawAudioProcessor);\n`\n);\n","import {\n  BaseConnection,\n  type SessionConfig,\n  type FormatConfig,\n  parseFormat,\n} from \"./BaseConnection\";\nimport { PACKAGE_VERSION } from \"../version\";\nimport { isValidSocketEvent, type OutgoingSocketEvent } from \"./events\";\nimport {\n  Room,\n  RoomEvent,\n  Track,\n  ConnectionState,\n  createLocalAudioTrack,\n} from \"livekit-client\";\nimport type {\n  RemoteAudioTrack,\n  Participant,\n  TrackPublication,\n  RemoteParticipant,\n} from \"livekit-client\";\nimport {\n  constructOverrides,\n  CONVERSATION_INITIATION_CLIENT_DATA_TYPE,\n} from \"./overrides\";\nimport { arrayBufferToBase64 } from \"./audio\";\nimport { loadRawAudioProcessor } from \"./rawAudioProcessor.generated\";\n\nconst DEFAULT_LIVEKIT_WS_URL = \"wss://livekit.rtc.elevenlabs.io\";\nconst HTTPS_API_ORIGIN = \"https://api.elevenlabs.io\";\n\n// Convert WSS origin to HTTPS for API calls\nfunction convertWssToHttps(origin: string): string {\n  return origin.replace(/^wss:\\/\\//, \"https://\");\n}\n\nexport type ConnectionConfig = SessionConfig & {\n  onDebug?: (info: unknown) => void;\n};\n\nexport class WebRTCConnection extends BaseConnection {\n  public conversationId: string;\n  public readonly inputFormat: FormatConfig;\n  public readonly outputFormat: FormatConfig;\n\n  private room: Room;\n  private isConnected = false;\n  private audioEventId = 1;\n  private audioCaptureContext: AudioContext | null = null;\n  private audioElements: HTMLAudioElement[] = [];\n  private outputDeviceId: string | null = null;\n\n  private outputAnalyser: AnalyserNode | null = null;\n  private outputFrequencyData: Uint8Array<ArrayBuffer> | null = null;\n\n  private constructor(\n    room: Room,\n    conversationId: string,\n    inputFormat: FormatConfig,\n    outputFormat: FormatConfig,\n    config: { onDebug?: (info: unknown) => void } = {}\n  ) {\n    super(config);\n    this.room = room;\n    this.conversationId = conversationId;\n    this.inputFormat = inputFormat;\n    this.outputFormat = outputFormat;\n\n    this.setupRoomEventListeners();\n  }\n\n  public static async create(\n    config: ConnectionConfig\n  ): Promise<WebRTCConnection> {\n    let conversationToken: string;\n\n    // Handle different authentication scenarios\n    if (\"conversationToken\" in config && config.conversationToken) {\n      // Direct token provided\n      conversationToken = config.conversationToken;\n    } else if (\"agentId\" in config && config.agentId) {\n      // Agent ID provided - fetch token from API\n      try {\n        const version = config.overrides?.client?.version || PACKAGE_VERSION;\n        const source = config.overrides?.client?.source || \"js_sdk\";\n        const configOrigin = config.origin ?? HTTPS_API_ORIGIN;\n        const origin = convertWssToHttps(configOrigin); //origin is wss, not https\n        const url = `${origin}/v1/convai/conversation/token?agent_id=${config.agentId}&source=${source}&version=${version}`;\n        const response = await fetch(url);\n\n        if (!response.ok) {\n          throw new Error(\n            `ElevenLabs API returned ${response.status} ${response.statusText}`\n          );\n        }\n\n        const data = await response.json();\n        conversationToken = data.token;\n\n        if (!conversationToken) {\n          throw new Error(\"No conversation token received from API\");\n        }\n      } catch (error) {\n        let msg = error instanceof Error ? error.message : String(error);\n        if (error instanceof Error && error.message.includes(\"401\")) {\n          msg =\n            \"Your agent has authentication enabled, but no signed URL or conversation token was provided.\";\n        }\n\n        throw new Error(\n          `Failed to fetch conversation token for agent ${config.agentId}: ${msg}`\n        );\n      }\n    } else {\n      throw new Error(\n        \"Either conversationToken or agentId is required for WebRTC connection\"\n      );\n    }\n\n    const room = new Room();\n\n    try {\n      // Create connection instance first to set up event listeners\n      const conversationId = `room_${Date.now()}`;\n      const inputFormat = parseFormat(\"pcm_48000\");\n      const outputFormat = parseFormat(\"pcm_48000\");\n      const connection = new WebRTCConnection(\n        room,\n        conversationId,\n        inputFormat,\n        outputFormat,\n        config\n      );\n\n      // Use configurable LiveKit URL or default if not provided\n      const livekitUrl = config.livekitUrl || DEFAULT_LIVEKIT_WS_URL;\n\n      // Connect to the LiveKit room and wait for the Connected event\n      await room.connect(livekitUrl, conversationToken);\n\n      // Wait for the Connected event to ensure isConnected is true\n      await new Promise<void>(resolve => {\n        if (connection.isConnected) {\n          resolve();\n        } else {\n          const onConnected = () => {\n            room.off(RoomEvent.Connected, onConnected);\n            resolve();\n          };\n          room.on(RoomEvent.Connected, onConnected);\n        }\n      });\n\n      if (room.name) {\n        connection.conversationId =\n          room.name.match(/(conv_[a-zA-Z0-9]+)/)?.[0] || room.name;\n      }\n\n      // Enable microphone only if not text-only mode\n      if (!config.textOnly) {\n        await room.localParticipant.setMicrophoneEnabled(true);\n      }\n\n      const overridesEvent = constructOverrides(config);\n\n      connection.debug({\n        type: CONVERSATION_INITIATION_CLIENT_DATA_TYPE,\n        message: overridesEvent,\n      });\n\n      await connection.sendMessage(overridesEvent);\n\n      return connection;\n    } catch (error) {\n      await room.disconnect();\n      throw error;\n    }\n  }\n\n  private setupRoomEventListeners() {\n    this.room.on(RoomEvent.Connected, async () => {\n      this.isConnected = true;\n      console.info(\"WebRTC room connected\");\n    });\n\n    this.room.on(RoomEvent.Disconnected, reason => {\n      this.isConnected = false;\n      this.disconnect({\n        reason: \"agent\",\n        context: new CloseEvent(\"close\", { reason: reason?.toString() }),\n      });\n    });\n\n    this.room.on(RoomEvent.ConnectionStateChanged, state => {\n      if (state === ConnectionState.Disconnected) {\n        this.isConnected = false;\n        this.disconnect({\n          reason: \"error\",\n          message: `LiveKit connection state changed to ${state}`,\n          context: new Event(\"connection_state_changed\"),\n        });\n      }\n    });\n\n    // Handle incoming data messages\n    this.room.on(\n      RoomEvent.DataReceived,\n      (payload: Uint8Array, _participant) => {\n        try {\n          const message = JSON.parse(new TextDecoder().decode(payload));\n\n          // Filter out audio messages for WebRTC - they're handled via audio tracks\n          if (message.type === \"audio\") {\n            return;\n          }\n\n          if (isValidSocketEvent(message)) {\n            this.handleMessage(message);\n          } else {\n            console.warn(\"Invalid socket event received:\", message);\n          }\n        } catch (error) {\n          console.warn(\"Failed to parse incoming data message:\", error);\n          console.warn(\"Raw payload:\", new TextDecoder().decode(payload));\n        }\n      }\n    );\n\n    this.room.on(\n      RoomEvent.TrackSubscribed,\n      async (\n        track: Track,\n        _publication: TrackPublication,\n        participant: Participant\n      ) => {\n        if (\n          track.kind === Track.Kind.Audio &&\n          participant.identity.includes(\"agent\")\n        ) {\n          // Play the audio track\n          const remoteAudioTrack = track as RemoteAudioTrack;\n          const audioElement = remoteAudioTrack.attach();\n          audioElement.autoplay = true;\n          audioElement.controls = false;\n\n          // Set output device if one was previously selected\n          if (this.outputDeviceId && audioElement.setSinkId) {\n            try {\n              await audioElement.setSinkId(this.outputDeviceId);\n            } catch (error) {\n              console.warn(\n                \"Failed to set output device for new audio element:\",\n                error\n              );\n            }\n          }\n\n          // Add to DOM (hidden) to ensure it plays\n          audioElement.style.display = \"none\";\n          document.body.appendChild(audioElement);\n\n          // Store reference for volume control\n          this.audioElements.push(audioElement);\n\n          // Apply current volume if it exists (for when volume was set before audio track arrived)\n          if (this.audioElements.length === 1) {\n            // First audio element - trigger a callback to sync with current volume\n            this.onDebug?.({ type: \"audio_element_ready\" });\n          }\n\n          // Set up audio capture for onAudio callback\n          await this.setupAudioCapture(remoteAudioTrack);\n        }\n      }\n    );\n\n    this.room.on(\n      RoomEvent.ActiveSpeakersChanged,\n      async (speakers: Participant[]) => {\n        if (speakers.length > 0) {\n          this.updateMode(\n            speakers[0].identity.startsWith(\"agent\") ? \"speaking\" : \"listening\"\n          );\n        } else {\n          this.updateMode(\"listening\");\n        }\n      }\n    );\n\n    this.room.on(\n      RoomEvent.ParticipantDisconnected,\n      (participant: RemoteParticipant) => {\n        if (participant.identity?.startsWith(\"agent\")) {\n          this.disconnect({\n            reason: \"agent\",\n            context: new CloseEvent(\"close\", { reason: \"agent disconnected\" }),\n          });\n        }\n      }\n    );\n  }\n\n  public close() {\n    if (this.isConnected) {\n      try {\n        // Explicitly stop all local tracks before disconnecting to ensure microphone is released\n        this.room.localParticipant.audioTrackPublications.forEach(\n          publication => {\n            if (publication.track) {\n              publication.track.stop();\n            }\n          }\n        );\n      } catch (error) {\n        console.warn(\"Error stopping local tracks:\", error);\n      }\n\n      // Clean up audio capture context (non-blocking)\n      if (this.audioCaptureContext) {\n        this.audioCaptureContext.close().catch(error => {\n          console.warn(\"Error closing audio capture context:\", error);\n        });\n        this.audioCaptureContext = null;\n      }\n\n      // Clean up audio elements\n      this.audioElements.forEach(element => {\n        if (element.parentNode) {\n          element.parentNode.removeChild(element);\n        }\n      });\n      this.audioElements = [];\n\n      this.room.disconnect();\n    }\n  }\n\n  public async sendMessage(message: OutgoingSocketEvent) {\n    if (!this.isConnected || !this.room.localParticipant) {\n      console.warn(\n        \"Cannot send message: room not connected or no local participant\"\n      );\n      return;\n    }\n\n    // In WebRTC mode, audio is sent via published tracks, not data messages\n    if (\"user_audio_chunk\" in message) {\n      // Ignore audio data messages - audio flows through WebRTC tracks\n      return;\n    }\n\n    try {\n      const encoder = new TextEncoder();\n      const data = encoder.encode(JSON.stringify(message));\n\n      await this.room.localParticipant.publishData(data, { reliable: true });\n    } catch (error) {\n      this.debug({\n        type: \"send_message_error\",\n        message: {\n          message,\n          error,\n        },\n      });\n      console.error(\"Failed to send message via WebRTC:\", error);\n    }\n  }\n\n  // Get the room instance for advanced usage\n  public getRoom(): Room {\n    return this.room;\n  }\n\n  public async setMicMuted(isMuted: boolean): Promise<void> {\n    if (!this.isConnected || !this.room.localParticipant) {\n      console.warn(\n        \"Cannot set microphone muted: room not connected or no local participant\"\n      );\n      return;\n    }\n\n    // Get the microphone track publication\n    const micTrackPublication = this.room.localParticipant.getTrackPublication(\n      Track.Source.Microphone\n    );\n\n    if (micTrackPublication?.track) {\n      try {\n        // Use LiveKit's built-in track muting\n        if (isMuted) {\n          await micTrackPublication.track.mute();\n        } else {\n          await micTrackPublication.track.unmute();\n        }\n      } catch (_error) {\n        // If track muting fails, fall back to participant-level control\n        await this.room.localParticipant.setMicrophoneEnabled(!isMuted);\n      }\n    } else {\n      // No track found, use participant-level control directly\n      await this.room.localParticipant.setMicrophoneEnabled(!isMuted);\n    }\n  }\n\n  private async setupAudioCapture(track: RemoteAudioTrack) {\n    try {\n      // Create audio context for processing\n      const audioContext = new AudioContext();\n      this.audioCaptureContext = audioContext;\n\n      // Create analyser for frequency data\n      this.outputAnalyser = audioContext.createAnalyser();\n      this.outputAnalyser.fftSize = 2048;\n      this.outputAnalyser.smoothingTimeConstant = 0.8;\n\n      // Create MediaStream from the track\n      const mediaStream = new MediaStream([track.mediaStreamTrack]);\n\n      // Create audio source from the stream\n      const source = audioContext.createMediaStreamSource(mediaStream);\n\n      // Connect source to analyser\n      source.connect(this.outputAnalyser);\n\n      await loadRawAudioProcessor(audioContext.audioWorklet);\n      const worklet = new AudioWorkletNode(audioContext, \"rawAudioProcessor\");\n\n      // Connect analyser to worklet for processing\n      this.outputAnalyser.connect(worklet);\n\n      // Configure the processor for the output format\n      worklet.port.postMessage({\n        type: \"setFormat\",\n        format: this.outputFormat.format,\n        sampleRate: this.outputFormat.sampleRate,\n      });\n\n      // Handle processed audio data\n      worklet.port.onmessage = (event: MessageEvent) => {\n        const [audioData, maxVolume] = event.data;\n\n        // Only send audio if there's significant volume (not just silence)\n        const volumeThreshold = 0.01;\n\n        if (maxVolume > volumeThreshold) {\n          // Convert to base64\n          const base64Audio = arrayBufferToBase64(audioData.buffer);\n\n          // Use sequential event ID for proper feedback tracking\n          const eventId = this.audioEventId++;\n\n          // Trigger the onAudio callback by simulating an audio event\n          this.handleMessage({\n            type: \"audio\",\n            audio_event: {\n              audio_base_64: base64Audio,\n              event_id: eventId,\n            },\n          });\n        }\n      };\n\n      // Connect the audio processing chain\n      source.connect(worklet);\n    } catch (error) {\n      console.warn(\"Failed to set up audio capture:\", error);\n    }\n  }\n\n  public setAudioVolume(volume: number) {\n    this.audioElements.forEach(element => {\n      element.volume = volume;\n    });\n  }\n\n  public async setAudioOutputDevice(deviceId: string): Promise<void> {\n    if (!(\"setSinkId\" in HTMLAudioElement.prototype)) {\n      throw new Error(\"setSinkId is not supported in this browser\");\n    }\n\n    // Set output device for all existing audio elements\n    const promises = this.audioElements.map(async element => {\n      try {\n        await element.setSinkId(deviceId);\n      } catch (error) {\n        console.error(\"Failed to set sink ID for audio element:\", error);\n        throw error;\n      }\n    });\n\n    await Promise.all(promises);\n\n    // Store the device ID for future audio elements\n    this.outputDeviceId = deviceId;\n  }\n\n  public async setAudioInputDevice(deviceId: string): Promise<void> {\n    if (!this.isConnected || !this.room.localParticipant) {\n      throw new Error(\n        \"Cannot change input device: room not connected or no local participant\"\n      );\n    }\n\n    try {\n      // Get the current microphone track publication\n      const currentMicTrackPublication =\n        this.room.localParticipant.getTrackPublication(Track.Source.Microphone);\n\n      // Stop the current microphone track if it exists\n      if (currentMicTrackPublication?.track) {\n        await currentMicTrackPublication.track.stop();\n        await this.room.localParticipant.unpublishTrack(\n          currentMicTrackPublication.track\n        );\n      }\n\n      // Create constraints for the new input device\n      const audioConstraints: MediaTrackConstraints = {\n        deviceId: { exact: deviceId },\n        echoCancellation: true,\n        noiseSuppression: true,\n        autoGainControl: true,\n        channelCount: { ideal: 1 },\n      };\n\n      // Create new audio track with the specified device\n      const audioTrack = await createLocalAudioTrack(audioConstraints);\n\n      // Publish the new microphone track\n      await this.room.localParticipant.publishTrack(audioTrack, {\n        name: \"microphone\",\n        source: Track.Source.Microphone,\n      });\n    } catch (error) {\n      console.error(\"Failed to change input device:\", error);\n\n      // Try to re-enable default microphone on failure\n      try {\n        await this.room.localParticipant.setMicrophoneEnabled(true);\n      } catch (recoveryError) {\n        console.error(\n          \"Failed to recover microphone after device switch error:\",\n          recoveryError\n        );\n      }\n\n      throw error;\n    }\n  }\n\n  public getOutputByteFrequencyData(): Uint8Array<ArrayBuffer> | null {\n    if (!this.outputAnalyser) return null;\n\n    this.outputFrequencyData ??= new Uint8Array(\n      this.outputAnalyser.frequencyBinCount\n    ) as Uint8Array<ArrayBuffer>;\n    this.outputAnalyser.getByteFrequencyData(this.outputFrequencyData);\n    return this.outputFrequencyData;\n  }\n}\n","import type {\n  BaseConnection,\n  SessionConfig,\n  ConnectionType,\n} from \"./BaseConnection\";\nimport { WebSocketConnection } from \"./WebSocketConnection\";\nimport { WebRTCConnection } from \"./WebRTCConnection\";\n\nfunction determineConnectionType(config: SessionConfig): ConnectionType {\n  // If connectionType is explicitly specified, use it\n  if (config.connectionType) {\n    return config.connectionType;\n  }\n\n  // If conversationToken is provided, use WebRTC\n  if (\"conversationToken\" in config && config.conversationToken) {\n    return \"webrtc\";\n  }\n\n  // Default to WebSocket for backward compatibility\n  return \"websocket\";\n}\n\nexport async function createConnection(\n  config: SessionConfig\n): Promise<BaseConnection> {\n  const connectionType = determineConnectionType(config);\n\n  switch (connectionType) {\n    case \"websocket\":\n      return WebSocketConnection.create(config);\n    case \"webrtc\":\n      return WebRTCConnection.create(config);\n    default:\n      throw new Error(`Unknown connection type: ${connectionType}`);\n  }\n}\n","export function isIosDevice() {\n  return (\n    [\n      \"iPad Simulator\",\n      \"iPhone Simulator\",\n      \"iPod Simulator\",\n      \"iPad\",\n      \"iPhone\",\n      \"iPod\",\n    ].includes(navigator.platform) ||\n    // iPad on iOS 13 detection\n    (navigator.userAgent.includes(\"Mac\") && \"ontouchend\" in document)\n  );\n}\n\nexport function isAndroidDevice() {\n  return /android/i.test(navigator.userAgent);\n}\n","import { isAndroidDevice, isIosDevice } from \"./compatibility\";\nimport type { DelayConfig } from \"./connection\";\n\nexport async function applyDelay(\n  delayConfig: DelayConfig = {\n    default: 0,\n    // Give the Android AudioManager enough time to switch to the correct audio mode\n    android: 3_000,\n  }\n) {\n  let delay = delayConfig.default;\n  if (isAndroidDevice()) {\n    delay = delayConfig.android ?? delay;\n  } else if (isIosDevice()) {\n    delay = delayConfig.ios ?? delay;\n  }\n\n  if (delay > 0) {\n    await new Promise(resolve => setTimeout(resolve, delay));\n  }\n}\n","import { createConnection } from \"./utils/ConnectionFactory\";\nimport type { BaseConnection } from \"./utils/BaseConnection\";\nimport { applyDelay } from \"./utils/applyDelay\";\nimport { BaseConversation, type PartialOptions } from \"./BaseConversation\";\n\nexport class TextConversation extends BaseConversation {\n  public static async startSession(\n    options: PartialOptions\n  ): Promise<TextConversation> {\n    const fullOptions = BaseConversation.getFullOptions(options);\n\n    if (fullOptions.onStatusChange) {\n      fullOptions.onStatusChange({ status: \"connecting\" });\n    }\n    if (fullOptions.onCanSendFeedbackChange) {\n      fullOptions.onCanSendFeedbackChange({ canSendFeedback: false });\n    }\n    if (fullOptions.onModeChange) {\n      fullOptions.onModeChange({ mode: \"listening\" });\n    }\n    if (fullOptions.onCanSendFeedbackChange) {\n      fullOptions.onCanSendFeedbackChange({ canSendFeedback: false });\n    }\n\n    let connection: BaseConnection | null = null;\n    try {\n      await applyDelay(fullOptions.connectionDelay);\n      connection = await createConnection(options);\n      return new TextConversation(fullOptions, connection);\n    } catch (error) {\n      if (fullOptions.onStatusChange) {\n        fullOptions.onStatusChange({ status: \"disconnected\" });\n      }\n      connection?.close();\n      throw error;\n    }\n  }\n}\n","import { loadRawAudioProcessor } from \"./rawAudioProcessor.generated\";\nimport type { FormatConfig } from \"./connection\";\nimport { isIosDevice } from \"./compatibility\";\nimport type { AudioWorkletConfig } from \"../BaseConversation\";\n\nexport type InputConfig = {\n  preferHeadphonesForIosDevices?: boolean;\n  inputDeviceId?: string;\n  onError?(message: string, context?: unknown): void;\n};\n\nconst LIBSAMPLERATE_JS =\n  \"https://cdn.jsdelivr.net/npm/@alexanderolsen/libsamplerate-js@2.1.2/dist/libsamplerate.worklet.js\";\n\nconst defaultConstraints = {\n  echoCancellation: true,\n  noiseSuppression: true,\n  // Automatic gain control helps maintain a steady volume level with microphones: https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/autoGainControl\n  autoGainControl: true,\n  // Mono audio for better echo cancellation\n  channelCount: { ideal: 1 },\n};\n\nexport class Input {\n  public static async create({\n    sampleRate,\n    format,\n    preferHeadphonesForIosDevices,\n    inputDeviceId,\n    workletPaths,\n    libsampleratePath,\n    onError,\n  }: FormatConfig & InputConfig & AudioWorkletConfig): Promise<Input> {\n    let context: AudioContext | null = null;\n    let inputStream: MediaStream | null = null;\n\n    try {\n      const options: MediaTrackConstraints = {\n        sampleRate: { ideal: sampleRate },\n        ...defaultConstraints,\n      };\n\n      if (isIosDevice() && preferHeadphonesForIosDevices) {\n        const availableDevices =\n          await window.navigator.mediaDevices.enumerateDevices();\n        const idealDevice = availableDevices.find(\n          d =>\n            // cautious to include \"bluetooth\" in the search\n            // as might trigger bluetooth speakers\n            d.kind === \"audioinput\" &&\n            [\"airpod\", \"headphone\", \"earphone\"].find(keyword =>\n              d.label.toLowerCase().includes(keyword)\n            )\n        );\n        if (idealDevice) {\n          options.deviceId = { ideal: idealDevice.deviceId };\n        }\n      }\n\n      if (inputDeviceId) {\n        options.deviceId = Input.getDeviceIdConstraint(inputDeviceId);\n      }\n\n      const supportsSampleRateConstraint =\n        navigator.mediaDevices.getSupportedConstraints().sampleRate;\n\n      context = new window.AudioContext(\n        supportsSampleRateConstraint ? { sampleRate } : {}\n      );\n      const analyser = context.createAnalyser();\n      if (!supportsSampleRateConstraint) {\n        // Use custom libsamplerate path if provided, otherwise fallback to CDN\n        const libsamplerateUrl = libsampleratePath || LIBSAMPLERATE_JS;\n        await context.audioWorklet.addModule(libsamplerateUrl);\n      }\n      await loadRawAudioProcessor(\n        context.audioWorklet,\n        workletPaths?.[\"rawAudioProcessor\"]\n      );\n\n      const constraints = { voiceIsolation: true, ...options };\n      inputStream = await navigator.mediaDevices.getUserMedia({\n        audio: constraints,\n      });\n\n      const source = context.createMediaStreamSource(inputStream);\n      const worklet = new AudioWorkletNode(context, \"rawAudioProcessor\");\n      worklet.port.postMessage({ type: \"setFormat\", format, sampleRate });\n\n      source.connect(analyser);\n      analyser.connect(worklet);\n\n      await context.resume();\n\n      const permissions = await navigator.permissions.query({\n        name: \"microphone\",\n      });\n      return new Input(\n        context,\n        analyser,\n        worklet,\n        inputStream,\n        source,\n        permissions,\n        onError\n      );\n    } catch (error) {\n      inputStream?.getTracks().forEach(track => {\n        track.stop();\n      });\n      context?.close();\n      throw error;\n    }\n  }\n\n  // Use { ideal } on iOS as a defensive measure - some iOS versions may not support { exact } for deviceId constraints\n  private static getDeviceIdConstraint(\n    inputDeviceId?: string\n  ): MediaTrackConstraints[\"deviceId\"] {\n    if (!inputDeviceId) {\n      return undefined;\n    }\n    return isIosDevice() ? { ideal: inputDeviceId } : { exact: inputDeviceId };\n  }\n\n  private constructor(\n    public readonly context: AudioContext,\n    public readonly analyser: AnalyserNode,\n    public readonly worklet: AudioWorkletNode,\n    public inputStream: MediaStream,\n    private mediaStreamSource: MediaStreamAudioSourceNode,\n    private permissions: PermissionStatus,\n    private onError: (\n      message: string,\n      context?: unknown\n    ) => void = console.error\n  ) {\n    this.permissions.addEventListener(\"change\", this.handlePermissionsChange);\n  }\n\n  private forgetInputStreamAndSource() {\n    for (const track of this.inputStream.getTracks()) {\n      track.stop();\n    }\n    this.mediaStreamSource.disconnect();\n  }\n\n  public async close() {\n    this.forgetInputStreamAndSource();\n    this.permissions.removeEventListener(\n      \"change\",\n      this.handlePermissionsChange\n    );\n    await this.context.close();\n  }\n\n  public setMuted(isMuted: boolean) {\n    this.worklet.port.postMessage({ type: \"setMuted\", isMuted });\n  }\n\n  private settingInput: boolean = false;\n  public async setInputDevice(inputDeviceId?: string): Promise<void> {\n    try {\n      if (this.settingInput) {\n        throw new Error(\"Input device is already being set\");\n      }\n      this.settingInput = true;\n      // Create new constraints with the specified device or use default\n      const options: MediaTrackConstraints = {\n        ...defaultConstraints,\n      };\n\n      if (inputDeviceId) {\n        options.deviceId = Input.getDeviceIdConstraint(inputDeviceId);\n      }\n      // If inputDeviceId is undefined, don't set deviceId constraint - browser uses default\n\n      const constraints = { voiceIsolation: true, ...options };\n\n      // Get new media stream with the specified device before forgetting the old one\n      // this prevents unintended interruption of the audio stream in case the new stream isn't obtained\n      const newInputStream = await navigator.mediaDevices.getUserMedia({\n        audio: constraints,\n      });\n\n      this.forgetInputStreamAndSource();\n\n      // Replace the stream and create new source\n      this.inputStream = newInputStream;\n      this.mediaStreamSource =\n        this.context.createMediaStreamSource(newInputStream);\n\n      // Reconnect the audio graph\n      this.mediaStreamSource.connect(this.analyser);\n    } catch (error) {\n      this.onError(\"Failed to switch input device:\", error);\n      throw error;\n    } finally {\n      this.settingInput = false;\n    }\n  }\n\n  private handlePermissionsChange = () => {\n    if (this.permissions.state === \"denied\") {\n      this.onError(\"Microphone permission denied\");\n      // TODO: Tell the user to grant permission in some other way\n    } else if (!this.settingInput) {\n      // Let's try to reset the input device, but only if we're not already in the process of setting it\n      const [track] = this.inputStream.getAudioTracks();\n      const { deviceId } = track?.getSettings() ?? {};\n      this.setInputDevice(deviceId).catch(error => {\n        this.onError(\n          \"Failed to reset input device after permission change:\",\n          error\n        );\n      });\n    }\n  };\n}\n","// AUTO-GENERATED BY packages/client/scripts/generateWorklets.js\nimport { createWorkletModuleLoader } from \"./createWorkletModuleLoader\";\n\nexport const loadAudioConcatProcessor = createWorkletModuleLoader(\n  \"audioConcatProcessor\",\n  // language=JavaScript\n  `/*\n * ulaw decoding logic taken from the wavefile library\n * https://github.com/rochars/wavefile/blob/master/lib/codecs/mulaw.js\n * USED BY @elevenlabs/client\n */\n\nconst decodeTable = [0,132,396,924,1980,4092,8316,16764];\n\nfunction decodeSample(muLawSample) {\n  let sign;\n  let exponent;\n  let mantissa;\n  let sample;\n  muLawSample = ~muLawSample;\n  sign = (muLawSample & 0x80);\n  exponent = (muLawSample >> 4) & 0x07;\n  mantissa = muLawSample & 0x0F;\n  sample = decodeTable[exponent] + (mantissa << (exponent+3));\n  if (sign !== 0) sample = -sample;\n\n  return sample;\n}\n\nclass AudioConcatProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n    this.buffers = []; // Initialize an empty buffer\n    this.cursor = 0;\n    this.currentBuffer = null;\n    this.wasInterrupted = false;\n    this.finished = false;\n    \n    this.port.onmessage = ({ data }) => {\n      switch (data.type) {\n        case \"setFormat\":\n          this.format = data.format;\n          break;\n        case \"buffer\":\n          this.wasInterrupted = false;\n          this.buffers.push(\n            this.format === \"ulaw\"\n              ? new Uint8Array(data.buffer)\n              : new Int16Array(data.buffer)\n          );\n          break;\n        case \"interrupt\":\n          this.wasInterrupted = true;\n          break;\n        case \"clearInterrupted\":\n          if (this.wasInterrupted) {\n            this.wasInterrupted = false;\n            this.buffers = [];\n            this.currentBuffer = null;\n          }\n      }\n    };\n  }\n  process(_, outputs) {\n    let finished = false;\n    const output = outputs[0][0];\n    for (let i = 0; i < output.length; i++) {\n      if (!this.currentBuffer) {\n        if (this.buffers.length === 0) {\n          finished = true;\n          break;\n        }\n        this.currentBuffer = this.buffers.shift();\n        this.cursor = 0;\n      }\n\n      let value = this.currentBuffer[this.cursor];\n      if (this.format === \"ulaw\") {\n        value = decodeSample(value);\n      }\n      output[i] = value / 32768;\n      this.cursor++;\n\n      if (this.cursor >= this.currentBuffer.length) {\n        this.currentBuffer = null;\n      }\n    }\n\n    if (this.finished !== finished) {\n      this.finished = finished;\n      this.port.postMessage({ type: \"process\", finished });\n    }\n\n    return true; // Continue processing\n  }\n}\n\nregisterProcessor(\"audioConcatProcessor\", AudioConcatProcessor);\n`\n);\n","import { loadAudioConcatProcessor } from \"./audioConcatProcessor.generated\";\nimport type { FormatConfig } from \"./connection\";\nimport type { AudioWorkletConfig } from \"../BaseConversation\";\n\nexport type OutputConfig = {\n  outputDeviceId?: string;\n};\n\nexport class Output {\n  public static async create({\n    sampleRate,\n    format,\n    outputDeviceId,\n    workletPaths,\n  }: FormatConfig & OutputConfig & AudioWorkletConfig): Promise<Output> {\n    let context: AudioContext | null = null;\n    let audioElement: HTMLAudioElement | null = null;\n    try {\n      context = new AudioContext({ sampleRate });\n      const analyser = context.createAnalyser();\n      const gain = context.createGain();\n\n      // Always create an audio element for device switching capability\n      audioElement = new Audio();\n      audioElement.src = \"\";\n      audioElement.load();\n      audioElement.autoplay = true;\n      audioElement.style.display = \"none\";\n\n      document.body.appendChild(audioElement);\n\n      // Create media stream destination to route audio to the element\n      const destination = context.createMediaStreamDestination();\n      audioElement.srcObject = destination.stream;\n\n      gain.connect(analyser);\n      analyser.connect(destination);\n\n      await loadAudioConcatProcessor(\n        context.audioWorklet,\n        workletPaths?.[\"audioConcatProcessor\"]\n      );\n      const worklet = new AudioWorkletNode(context, \"audioConcatProcessor\");\n      worklet.port.postMessage({ type: \"setFormat\", format });\n      worklet.connect(gain);\n\n      await context.resume();\n\n      // Set initial output device if provided\n      if (outputDeviceId && audioElement.setSinkId) {\n        await audioElement.setSinkId(outputDeviceId);\n      }\n\n      const newOutput = new Output(\n        context,\n        analyser,\n        gain,\n        worklet,\n        audioElement\n      );\n\n      return newOutput;\n    } catch (error) {\n      // Clean up audio element from DOM\n      if (audioElement?.parentNode) {\n        audioElement.parentNode.removeChild(audioElement);\n      }\n      audioElement?.pause();\n      if (context && context.state !== \"closed\") {\n        await context.close();\n      }\n\n      throw error;\n    }\n  }\n\n  private constructor(\n    public readonly context: AudioContext,\n    public readonly analyser: AnalyserNode,\n    public readonly gain: GainNode,\n    public readonly worklet: AudioWorkletNode,\n    public readonly audioElement: HTMLAudioElement\n  ) {}\n\n  public async setOutputDevice(deviceId?: string): Promise<void> {\n    if (!(\"setSinkId\" in HTMLAudioElement.prototype)) {\n      throw new Error(\"setSinkId is not supported in this browser\");\n    }\n\n    // If deviceId is undefined, use empty string which resets to default device\n    await this.audioElement.setSinkId(deviceId || \"\");\n  }\n\n  public async close() {\n    // Remove audio element from DOM\n    if (this.audioElement.parentNode) {\n      this.audioElement.parentNode.removeChild(this.audioElement);\n    }\n    this.audioElement.pause();\n    await this.context.close();\n  }\n}\n","import { arrayBufferToBase64, base64ToArrayBuffer } from \"./utils/audio\";\nimport { Input, type InputConfig } from \"./utils/input\";\nimport { Output } from \"./utils/output\";\nimport { createConnection } from \"./utils/ConnectionFactory\";\nimport type { BaseConnection, FormatConfig } from \"./utils/BaseConnection\";\nimport { WebRTCConnection } from \"./utils/WebRTCConnection\";\nimport type { AgentAudioEvent, InterruptionEvent } from \"./utils/events\";\nimport { applyDelay } from \"./utils/applyDelay\";\nimport {\n  BaseConversation,\n  type Options,\n  type PartialOptions,\n} from \"./BaseConversation\";\nimport { WebSocketConnection } from \"./utils/WebSocketConnection\";\n\nexport class VoiceConversation extends BaseConversation {\n  private static async requestWakeLock(): Promise<WakeLockSentinel | null> {\n    if (\"wakeLock\" in navigator) {\n      // unavailable without HTTPS, including localhost in dev\n      try {\n        return await navigator.wakeLock.request(\"screen\");\n      } catch (_e) {\n        // Wake Lock is not required for the conversation to work\n      }\n    }\n    return null;\n  }\n\n  public static async startSession(\n    options: PartialOptions\n  ): Promise<VoiceConversation> {\n    const fullOptions = BaseConversation.getFullOptions(options);\n\n    if (fullOptions.onStatusChange) {\n      fullOptions.onStatusChange({ status: \"connecting\" });\n    }\n    if (fullOptions.onCanSendFeedbackChange) {\n      fullOptions.onCanSendFeedbackChange({ canSendFeedback: false });\n    }\n\n    let input: Input | null = null;\n    let connection: BaseConnection | null = null;\n    let output: Output | null = null;\n    let preliminaryInputStream: MediaStream | null = null;\n\n    const useWakeLock = options.useWakeLock ?? true;\n    let wakeLock: WakeLockSentinel | null = null;\n    if (useWakeLock) {\n      wakeLock = await VoiceConversation.requestWakeLock();\n    }\n\n    try {\n      // some browsers won't allow calling getSupportedConstraints or enumerateDevices\n      // before getting approval for microphone access\n      preliminaryInputStream = await navigator.mediaDevices.getUserMedia({\n        audio: true,\n      });\n\n      await applyDelay(fullOptions.connectionDelay);\n      connection = await createConnection(options);\n      [input, output] = await Promise.all([\n        Input.create({\n          ...connection.inputFormat,\n          preferHeadphonesForIosDevices: options.preferHeadphonesForIosDevices,\n          inputDeviceId: options.inputDeviceId,\n          workletPaths: options.workletPaths,\n          libsampleratePath: options.libsampleratePath,\n        }),\n        Output.create({\n          ...connection.outputFormat,\n          outputDeviceId: options.outputDeviceId,\n          workletPaths: options.workletPaths,\n        }),\n      ]);\n\n      preliminaryInputStream?.getTracks().forEach(track => {\n        track.stop();\n      });\n      preliminaryInputStream = null;\n\n      return new VoiceConversation(\n        fullOptions,\n        connection,\n        input,\n        output,\n        wakeLock\n      );\n    } catch (error) {\n      if (fullOptions.onStatusChange) {\n        fullOptions.onStatusChange({ status: \"disconnected\" });\n      }\n      preliminaryInputStream?.getTracks().forEach(track => {\n        track.stop();\n      });\n      connection?.close();\n      await input?.close();\n      await output?.close();\n      try {\n        await wakeLock?.release();\n        wakeLock = null;\n      } catch (_e) {}\n      throw error;\n    }\n  }\n\n  private inputFrequencyData?: Uint8Array<ArrayBuffer>;\n  private outputFrequencyData?: Uint8Array<ArrayBuffer>;\n  private visibilityChangeHandler: (() => void) | null = null;\n\n  protected constructor(\n    options: Options,\n    connection: BaseConnection,\n    public input: Input,\n    public output: Output,\n    public wakeLock: WakeLockSentinel | null\n  ) {\n    super(options, connection);\n    this.input.worklet.port.onmessage = this.onInputWorkletMessage;\n    this.output.worklet.port.onmessage = this.onOutputWorkletMessage;\n\n    if (wakeLock) {\n      // Wake locks are automatically released when a page is hidden like when switching tabs\n      // so attempt to re-acquire lock when page becomes visible again\n      this.visibilityChangeHandler = () => {\n        if (document.visibilityState === \"visible\" && this.wakeLock?.released) {\n          VoiceConversation.requestWakeLock().then(lock => {\n            this.wakeLock = lock;\n          });\n        }\n      };\n      document.addEventListener(\n        \"visibilitychange\",\n        this.visibilityChangeHandler\n      );\n    }\n  }\n\n  protected override async handleEndSession() {\n    await super.handleEndSession();\n\n    if (this.visibilityChangeHandler) {\n      document.removeEventListener(\n        \"visibilitychange\",\n        this.visibilityChangeHandler\n      );\n    }\n\n    try {\n      await this.wakeLock?.release();\n      this.wakeLock = null;\n    } catch (_e) {}\n\n    await this.input.close();\n    await this.output.close();\n  }\n\n  protected override handleInterruption(event: InterruptionEvent) {\n    super.handleInterruption(event);\n    this.fadeOutAudio();\n  }\n\n  protected override handleAudio(event: AgentAudioEvent) {\n    super.handleAudio(event);\n\n    if (event.audio_event.alignment && this.options.onAudioAlignment) {\n      this.options.onAudioAlignment(event.audio_event.alignment);\n    }\n\n    if (this.lastInterruptTimestamp <= event.audio_event.event_id) {\n      if (event.audio_event.audio_base_64) {\n        this.options.onAudio?.(event.audio_event.audio_base_64);\n\n        // Only play audio through the output worklet for WebSocket connections\n        // WebRTC connections handle audio playback directly through LiveKit tracks\n        if (!(this.connection instanceof WebRTCConnection)) {\n          this.addAudioBase64Chunk(event.audio_event.audio_base_64);\n        }\n      }\n\n      this.currentEventId = event.audio_event.event_id;\n      this.updateCanSendFeedback();\n      this.updateMode(\"speaking\");\n    }\n  }\n\n  private onInputWorkletMessage = (event: MessageEvent): void => {\n    const rawAudioPcmData = event.data[0];\n\n    // TODO: When supported, maxVolume can be used to avoid sending silent audio\n    // const maxVolume = event.data[1];\n\n    if (this.status === \"connected\") {\n      this.connection.sendMessage({\n        user_audio_chunk: arrayBufferToBase64(rawAudioPcmData.buffer),\n      });\n    }\n  };\n\n  private onOutputWorkletMessage = ({ data }: MessageEvent): void => {\n    if (data.type === \"process\") {\n      this.updateMode(data.finished ? \"listening\" : \"speaking\");\n    }\n  };\n\n  private addAudioBase64Chunk = (chunk: string) => {\n    this.output.gain.gain.cancelScheduledValues(\n      this.output.context.currentTime\n    );\n    this.output.gain.gain.value = this.volume;\n    this.output.worklet.port.postMessage({ type: \"clearInterrupted\" });\n    this.output.worklet.port.postMessage({\n      type: \"buffer\",\n      buffer: base64ToArrayBuffer(chunk),\n    });\n  };\n\n  private fadeOutAudio = () => {\n    // mute agent\n    this.updateMode(\"listening\");\n    this.output.worklet.port.postMessage({ type: \"interrupt\" });\n    this.output.gain.gain.exponentialRampToValueAtTime(\n      0.0001,\n      this.output.context.currentTime + 2\n    );\n\n    // reset volume back\n    setTimeout(() => {\n      this.output.gain.gain.value = this.volume;\n      this.output.worklet.port.postMessage({ type: \"clearInterrupted\" });\n    }, 2000); // Adjust the duration as needed\n  };\n\n  private calculateVolume = (frequencyData: Uint8Array) => {\n    if (frequencyData.length === 0) {\n      return 0;\n    }\n\n    // TODO: Currently this averages all frequencies, but we should probably\n    // bias towards the frequencies that are more typical for human voice\n    let volume = 0;\n    for (let i = 0; i < frequencyData.length; i++) {\n      volume += frequencyData[i] / 255;\n    }\n    volume /= frequencyData.length;\n\n    return volume < 0 ? 0 : volume > 1 ? 1 : volume;\n  };\n\n  public setMicMuted(isMuted: boolean) {\n    // Use LiveKit track muting for WebRTC connections\n    if (this.connection instanceof WebRTCConnection) {\n      this.connection.setMicMuted(isMuted);\n    } else {\n      // Use input muting for WebSocket connections\n      this.input.setMuted(isMuted);\n    }\n  }\n\n  public getInputByteFrequencyData(): Uint8Array<ArrayBuffer> {\n    this.inputFrequencyData ??= new Uint8Array(\n      this.input.analyser.frequencyBinCount\n    ) as Uint8Array<ArrayBuffer>;\n    this.input.analyser.getByteFrequencyData(this.inputFrequencyData);\n    return this.inputFrequencyData;\n  }\n\n  public getOutputByteFrequencyData(): Uint8Array<ArrayBuffer> {\n    // Use WebRTC analyser if available\n    if (this.connection instanceof WebRTCConnection) {\n      const webrtcData = this.connection.getOutputByteFrequencyData();\n      if (webrtcData) {\n        return webrtcData as Uint8Array<ArrayBuffer>;\n      }\n      // Fallback to empty array if WebRTC analyser not ready\n      return new Uint8Array(1024) as Uint8Array<ArrayBuffer>;\n    }\n\n    this.outputFrequencyData ??= new Uint8Array(\n      this.output.analyser.frequencyBinCount\n    ) as Uint8Array<ArrayBuffer>;\n    this.output.analyser.getByteFrequencyData(this.outputFrequencyData);\n    return this.outputFrequencyData;\n  }\n\n  public getInputVolume() {\n    return this.calculateVolume(this.getInputByteFrequencyData());\n  }\n\n  public getOutputVolume() {\n    return this.calculateVolume(this.getOutputByteFrequencyData());\n  }\n\n  public async changeInputDevice({\n    sampleRate,\n    format,\n    preferHeadphonesForIosDevices,\n    inputDeviceId,\n  }: FormatConfig & InputConfig): Promise<Input> {\n    try {\n      // For WebSocket connections, try to change device on existing input first\n      if (this.connection instanceof WebSocketConnection) {\n        try {\n          await this.input.setInputDevice(inputDeviceId);\n          return this.input;\n        } catch (error) {\n          console.warn(\n            \"Failed to change device on existing input, recreating:\",\n            error\n          );\n          // Fall back to recreating the input\n        }\n      }\n\n      // Handle WebRTC connections differently\n      if (this.connection instanceof WebRTCConnection) {\n        await this.connection.setAudioInputDevice(inputDeviceId || \"\");\n      }\n\n      // Fallback: recreate the input\n      await this.input.close();\n\n      const newInput = await Input.create({\n        sampleRate: sampleRate ?? this.connection.inputFormat.sampleRate,\n        format: format ?? this.connection.inputFormat.format,\n        preferHeadphonesForIosDevices,\n        inputDeviceId,\n        workletPaths: this.options.workletPaths,\n        libsampleratePath: this.options.libsampleratePath,\n        onError: this.options.onError,\n      });\n\n      this.input = newInput;\n      this.input.worklet.port.onmessage = this.onInputWorkletMessage;\n\n      return this.input;\n    } catch (error) {\n      console.error(\"Error changing input device\", error);\n      throw error;\n    }\n  }\n\n  public async changeOutputDevice({\n    sampleRate,\n    format,\n    outputDeviceId,\n  }: FormatConfig): Promise<Output> {\n    try {\n      // For WebSocket connections, try to change device on existing output first\n      if (this.connection instanceof WebSocketConnection) {\n        try {\n          await this.output.setOutputDevice(outputDeviceId);\n          return this.output;\n        } catch (error) {\n          console.warn(\n            \"Failed to change device on existing output, recreating:\",\n            error\n          );\n          // Fall back to recreating the output\n        }\n      }\n\n      // Handle WebRTC connections differently\n      if (this.connection instanceof WebRTCConnection) {\n        await this.connection.setAudioOutputDevice(outputDeviceId || \"\");\n      }\n\n      // Fallback: recreate the output\n      await this.output.close();\n\n      const newOutput = await Output.create({\n        sampleRate: sampleRate ?? this.connection.outputFormat.sampleRate,\n        format: format ?? this.connection.outputFormat.format,\n        outputDeviceId,\n        workletPaths: this.options.workletPaths,\n      });\n\n      this.output = newOutput;\n\n      return this.output;\n    } catch (error) {\n      console.error(\"Error changing output device\", error);\n      throw error;\n    }\n  }\n\n  public setVolume = ({ volume }: { volume: number }) => {\n    // clamp & coerce\n    const clampedVolume = Number.isFinite(volume)\n      ? Math.min(1, Math.max(0, volume))\n      : 1;\n    this.volume = clampedVolume;\n\n    if (this.connection instanceof WebRTCConnection) {\n      // For WebRTC connections, control volume via HTML audio elements\n      this.connection.setAudioVolume(clampedVolume);\n    } else {\n      // For WebSocket connections, control volume via gain node\n      this.output.gain.gain.value = clampedVolume;\n    }\n  };\n}\n","import type {\n  InputAudioChunk,\n  SessionStartedMessage,\n  PartialTranscriptMessage,\n  CommittedTranscriptMessage,\n  CommittedTranscriptWithTimestampsMessage,\n  ScribeErrorMessage,\n  ScribeAuthErrorMessage,\n  ScribeQuotaExceededErrorMessage,\n  ScribeCommitThrottledErrorMessage,\n  ScribeTranscriberErrorMessage,\n  ScribeUnacceptedTermsErrorMessage,\n  ScribeRateLimitedErrorMessage,\n  ScribeInputErrorMessage,\n  ScribeQueueOverflowErrorMessage,\n  ScribeResourceExhaustedErrorMessage,\n  ScribeSessionTimeLimitExceededErrorMessage,\n  ScribeChunkSizeExceededErrorMessage,\n  ScribeInsufficientAudioActivityErrorMessage,\n} from \"@elevenlabs/types\";\n\n// Re-export types for public API\nexport type {\n  SessionStartedMessage,\n  PartialTranscriptMessage,\n  CommittedTranscriptMessage,\n  CommittedTranscriptWithTimestampsMessage,\n  ScribeErrorMessage,\n  ScribeAuthErrorMessage,\n  ScribeQuotaExceededErrorMessage,\n  ScribeCommitThrottledErrorMessage,\n  ScribeTranscriberErrorMessage,\n  ScribeUnacceptedTermsErrorMessage,\n  ScribeRateLimitedErrorMessage,\n  ScribeInputErrorMessage,\n  ScribeQueueOverflowErrorMessage,\n  ScribeResourceExhaustedErrorMessage,\n  ScribeSessionTimeLimitExceededErrorMessage,\n  ScribeChunkSizeExceededErrorMessage,\n  ScribeInsufficientAudioActivityErrorMessage,\n};\n\nexport type WebSocketMessage =\n  | SessionStartedMessage\n  | PartialTranscriptMessage\n  | CommittedTranscriptMessage\n  | CommittedTranscriptWithTimestampsMessage\n  | ScribeErrorMessage\n  | ScribeAuthErrorMessage\n  | ScribeQuotaExceededErrorMessage\n  | ScribeCommitThrottledErrorMessage\n  | ScribeTranscriberErrorMessage\n  | ScribeUnacceptedTermsErrorMessage\n  | ScribeRateLimitedErrorMessage\n  | ScribeInputErrorMessage\n  | ScribeQueueOverflowErrorMessage\n  | ScribeResourceExhaustedErrorMessage\n  | ScribeSessionTimeLimitExceededErrorMessage\n  | ScribeChunkSizeExceededErrorMessage\n  | ScribeInsufficientAudioActivityErrorMessage;\n\n/**\n * Simple EventEmitter implementation for browser compatibility.\n */\nclass EventEmitter {\n  private listeners: Map<string, Set<(...args: unknown[]) => void>> = new Map();\n\n  on(event: string, listener: (...args: unknown[]) => void): void {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n    const eventListeners = this.listeners.get(event);\n    if (eventListeners) {\n      eventListeners.add(listener);\n    }\n  }\n\n  off(event: string, listener: (...args: unknown[]) => void): void {\n    const eventListeners = this.listeners.get(event);\n    if (eventListeners) {\n      eventListeners.delete(listener);\n    }\n  }\n\n  emit(event: string, ...args: unknown[]): void {\n    const eventListeners = this.listeners.get(event);\n    if (eventListeners) {\n      eventListeners.forEach(listener => {\n        listener(...args);\n      });\n    }\n  }\n}\n\n/**\n * Events emitted by the RealtimeConnection.\n */\nexport enum RealtimeEvents {\n  /** Emitted when the session is successfully started */\n  SESSION_STARTED = \"session_started\",\n  /** Emitted when a partial (interim) transcript is available */\n  PARTIAL_TRANSCRIPT = \"partial_transcript\",\n  /** Emitted when a final transcript is available */\n  COMMITTED_TRANSCRIPT = \"committed_transcript\",\n  /** Emitted when a final transcript with timestamps is available */\n  COMMITTED_TRANSCRIPT_WITH_TIMESTAMPS = \"committed_transcript_with_timestamps\",\n  /** Emitted when an authentication error occurs */\n  AUTH_ERROR = \"auth_error\",\n  /** Emitted when an error occurs (also emitted for all specific error types) */\n  ERROR = \"error\",\n  /** Emitted when the WebSocket connection is opened */\n  OPEN = \"open\",\n  /** Emitted when the WebSocket connection is closed */\n  CLOSE = \"close\",\n  /** Emitted when a quota exceeded error occurs */\n  QUOTA_EXCEEDED = \"quota_exceeded\",\n  /** Emitted when commit is throttled */\n  COMMIT_THROTTLED = \"commit_throttled\",\n  /** Emitted when a transcriber error occurs */\n  TRANSCRIBER_ERROR = \"transcriber_error\",\n  /** Emitted when terms have not been accepted */\n  UNACCEPTED_TERMS = \"unaccepted_terms\",\n  /** Emitted when rate limited */\n  RATE_LIMITED = \"rate_limited\",\n  /** Emitted when there's an input error */\n  INPUT_ERROR = \"input_error\",\n  /** Emitted when the queue overflows */\n  QUEUE_OVERFLOW = \"queue_overflow\",\n  /** Emitted when resources are exhausted */\n  RESOURCE_EXHAUSTED = \"resource_exhausted\",\n  /** Emitted when session time limit is exceeded */\n  SESSION_TIME_LIMIT_EXCEEDED = \"session_time_limit_exceeded\",\n  /** Emitted when chunk size is exceeded */\n  CHUNK_SIZE_EXCEEDED = \"chunk_size_exceeded\",\n  /** Emitted when there's insufficient audio activity */\n  INSUFFICIENT_AUDIO_ACTIVITY = \"insufficient_audio_activity\",\n}\n\n/**\n * Map of event types to their payload types.\n */\nexport interface RealtimeEventMap {\n  [RealtimeEvents.SESSION_STARTED]: SessionStartedMessage;\n  [RealtimeEvents.PARTIAL_TRANSCRIPT]: PartialTranscriptMessage;\n  [RealtimeEvents.COMMITTED_TRANSCRIPT]: CommittedTranscriptMessage;\n  [RealtimeEvents.COMMITTED_TRANSCRIPT_WITH_TIMESTAMPS]: CommittedTranscriptWithTimestampsMessage;\n  [RealtimeEvents.ERROR]: ScribeErrorMessage;\n  [RealtimeEvents.AUTH_ERROR]: ScribeAuthErrorMessage;\n  [RealtimeEvents.QUOTA_EXCEEDED]: ScribeQuotaExceededErrorMessage;\n  [RealtimeEvents.COMMIT_THROTTLED]: ScribeCommitThrottledErrorMessage;\n  [RealtimeEvents.TRANSCRIBER_ERROR]: ScribeTranscriberErrorMessage;\n  [RealtimeEvents.UNACCEPTED_TERMS]: ScribeUnacceptedTermsErrorMessage;\n  [RealtimeEvents.RATE_LIMITED]: ScribeRateLimitedErrorMessage;\n  [RealtimeEvents.INPUT_ERROR]: ScribeInputErrorMessage;\n  [RealtimeEvents.QUEUE_OVERFLOW]: ScribeQueueOverflowErrorMessage;\n  [RealtimeEvents.RESOURCE_EXHAUSTED]: ScribeResourceExhaustedErrorMessage;\n  [RealtimeEvents.SESSION_TIME_LIMIT_EXCEEDED]: ScribeSessionTimeLimitExceededErrorMessage;\n  [RealtimeEvents.CHUNK_SIZE_EXCEEDED]: ScribeChunkSizeExceededErrorMessage;\n  [RealtimeEvents.INSUFFICIENT_AUDIO_ACTIVITY]: ScribeInsufficientAudioActivityErrorMessage;\n  [RealtimeEvents.OPEN]: undefined;\n  [RealtimeEvents.CLOSE]: CloseEvent;\n}\n\n/**\n * Manages a real-time transcription WebSocket connection.\n *\n * @example\n * ```typescript\n * const connection = await Scribe.connect({\n *     token: \"...\",\n *     modelId: \"scribe_v2_realtime\",\n *     audioFormat: AudioFormat.PCM_16000,\n *     sampleRate: 16000,\n * });\n *\n * connection.on(RealtimeEvents.SESSION_STARTED, (data) => {\n *     console.log(\"Session started\");\n * });\n *\n * connection.on(RealtimeEvents.PARTIAL_TRANSCRIPT, (data) => {\n *     console.log(\"Partial:\", data.transcript);\n * });\n *\n * connection.on(RealtimeEvents.COMMITTED_TRANSCRIPT, (data) => {\n *     console.log(\"Final:\", data.transcript);\n *     connection.close();\n * });\n *\n * // Send audio data\n * connection.send({ audioBase64: base64String });\n *\n * // Commit and close\n * connection.commit();\n * ```\n */\nexport class RealtimeConnection {\n  private websocket: WebSocket | null = null;\n  private eventEmitter: EventEmitter = new EventEmitter();\n  private currentSampleRate: number = 16000;\n  public _audioCleanup?: () => void;\n\n  constructor(sampleRate: number) {\n    this.currentSampleRate = sampleRate;\n  }\n\n  /**\n   * @internal\n   * Used internally by ScribeRealtime to attach the WebSocket after connection is created.\n   */\n  public setWebSocket(websocket: WebSocket): void {\n    this.websocket = websocket;\n\n    // If WebSocket is already open, emit OPEN event immediately\n    if (this.websocket.readyState === WebSocket.OPEN) {\n      this.eventEmitter.emit(RealtimeEvents.OPEN);\n    } else {\n      // Otherwise, wait for the open event\n      this.websocket.addEventListener(\"open\", () => {\n        this.eventEmitter.emit(RealtimeEvents.OPEN);\n      });\n    }\n\n    this.websocket.addEventListener(\"message\", (event: MessageEvent) => {\n      try {\n        const data = JSON.parse(event.data) as WebSocketMessage;\n\n        switch (data.message_type) {\n          case \"session_started\":\n            this.eventEmitter.emit(RealtimeEvents.SESSION_STARTED, data);\n            break;\n          case \"partial_transcript\":\n            this.eventEmitter.emit(RealtimeEvents.PARTIAL_TRANSCRIPT, data);\n            break;\n          case \"committed_transcript\":\n            this.eventEmitter.emit(RealtimeEvents.COMMITTED_TRANSCRIPT, data);\n            break;\n          case \"committed_transcript_with_timestamps\":\n            this.eventEmitter.emit(\n              RealtimeEvents.COMMITTED_TRANSCRIPT_WITH_TIMESTAMPS,\n              data\n            );\n            break;\n          // Error cases - emit both specific event and generic ERROR\n          case \"auth_error\":\n            this.eventEmitter.emit(RealtimeEvents.AUTH_ERROR, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"quota_exceeded\":\n            this.eventEmitter.emit(RealtimeEvents.QUOTA_EXCEEDED, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"commit_throttled\":\n            this.eventEmitter.emit(RealtimeEvents.COMMIT_THROTTLED, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"transcriber_error\":\n            this.eventEmitter.emit(RealtimeEvents.TRANSCRIBER_ERROR, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"unaccepted_terms\":\n            this.eventEmitter.emit(RealtimeEvents.UNACCEPTED_TERMS, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"rate_limited\":\n            this.eventEmitter.emit(RealtimeEvents.RATE_LIMITED, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"input_error\":\n            this.eventEmitter.emit(RealtimeEvents.INPUT_ERROR, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"queue_overflow\":\n            this.eventEmitter.emit(RealtimeEvents.QUEUE_OVERFLOW, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"resource_exhausted\":\n            this.eventEmitter.emit(RealtimeEvents.RESOURCE_EXHAUSTED, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"session_time_limit_exceeded\":\n            this.eventEmitter.emit(\n              RealtimeEvents.SESSION_TIME_LIMIT_EXCEEDED,\n              data\n            );\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"chunk_size_exceeded\":\n            this.eventEmitter.emit(RealtimeEvents.CHUNK_SIZE_EXCEEDED, data);\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"insufficient_audio_activity\":\n            this.eventEmitter.emit(\n              RealtimeEvents.INSUFFICIENT_AUDIO_ACTIVITY,\n              data\n            );\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          case \"error\":\n            this.eventEmitter.emit(RealtimeEvents.ERROR, data);\n            break;\n          default:\n            console.warn(\"Unknown message type:\", data);\n        }\n      } catch (error) {\n        console.error(\"Failed to parse WebSocket message:\", error, event.data);\n        this.eventEmitter.emit(\n          RealtimeEvents.ERROR,\n          new Error(`Failed to parse message: ${error}`)\n        );\n      }\n    });\n\n    this.websocket.addEventListener(\"error\", (error: Event) => {\n      console.error(\"WebSocket error:\", error);\n      this.eventEmitter.emit(RealtimeEvents.ERROR, error);\n    });\n\n    this.websocket.addEventListener(\"close\", (event: CloseEvent) => {\n      console.log(\n        `WebSocket closed: code=${event.code}, reason=\"${event.reason}\", wasClean=${event.wasClean}`\n      );\n\n      // Emit error if close was not clean or had an error code\n      if (!event.wasClean || (event.code !== 1000 && event.code !== 1005)) {\n        const errorMessage = `WebSocket closed unexpectedly: ${event.code} - ${event.reason || \"No reason provided\"}`;\n        console.error(errorMessage);\n        this.eventEmitter.emit(RealtimeEvents.ERROR, new Error(errorMessage));\n      }\n\n      this.eventEmitter.emit(RealtimeEvents.CLOSE, event);\n    });\n  }\n\n  /**\n   * Attaches an event listener for the specified event.\n   *\n   * @param event - The event to listen for (use RealtimeEvents enum)\n   * @param listener - The callback function to execute when the event fires\n   *\n   * @example\n   * ```typescript\n   * connection.on(RealtimeEvents.SESSION_STARTED, (data) => {\n   *     console.log(\"Session started\", data.session_id);\n   * });\n   *\n   * connection.on(RealtimeEvents.PARTIAL_TRANSCRIPT, (data) => {\n   *     console.log(\"Partial:\", data.text);\n   * });\n   *\n   * connection.on(RealtimeEvents.COMMITTED_TRANSCRIPT, (data) => {\n   *     console.log(\"Final:\", data.text);\n   * });\n   * ```\n   */\n  public on<E extends RealtimeEvents>(\n    event: E,\n    listener: RealtimeEventMap[E] extends undefined\n      ? () => void\n      : (data: RealtimeEventMap[E]) => void\n  ): void {\n    this.eventEmitter.on(event, listener as (...args: unknown[]) => void);\n  }\n\n  /**\n   * Removes an event listener for the specified event.\n   *\n   * @param event - The event to stop listening for\n   * @param listener - The callback function to remove\n   *\n   * @example\n   * ```typescript\n   * const handler = (data: PartialTranscriptMessage) => console.log(data.text);\n   * connection.on(RealtimeEvents.PARTIAL_TRANSCRIPT, handler);\n   *\n   * // Later, remove the listener\n   * connection.off(RealtimeEvents.PARTIAL_TRANSCRIPT, handler);\n   * ```\n   */\n  public off<E extends RealtimeEvents>(\n    event: E,\n    listener: RealtimeEventMap[E] extends undefined\n      ? () => void\n      : (data: RealtimeEventMap[E]) => void\n  ): void {\n    this.eventEmitter.off(event, listener as (...args: unknown[]) => void);\n  }\n\n  /**\n   * Sends audio data to the transcription service.\n   *\n   * @param data - Audio data configuration\n   * @param data.audioBase64 - Base64-encoded audio data\n   * @param data.commit - Whether to commit the transcription after this chunk. You likely want to use connection.commit() instead (default: false)\n   * @param data.sampleRate - Sample rate of the audio (default: configured sample rate)\n   * @param data.previousText - Send context to the model via base64 encoded audio or text from a previous transcription. Can only be sent alongside the first audio chunk. If sent in a subsequent chunk, an error will be returned.\n   *\n   * @throws {Error} If the WebSocket connection is not open\n   *\n   * @example\n   * ```typescript\n   * // Send audio chunk without committing\n   * connection.send({\n   *     audioBase64: base64EncodedAudio,\n   * });\n   *\n   * // Send audio chunk with custom sample rate and previous text\n   * connection.send({\n   *     audioBase64: base64EncodedAudio,\n   *     sampleRate: 16000,\n   *     previousText: \"Previous transcription text\",\n   * });\n   * ```\n   */\n  public send(data: {\n    audioBase64: string;\n    commit?: boolean;\n    sampleRate?: number;\n    previousText?: string;\n  }): void {\n    if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) {\n      throw new Error(\"WebSocket is not connected\");\n    }\n\n    const message: InputAudioChunk = {\n      message_type: \"input_audio_chunk\",\n      audio_base_64: data.audioBase64,\n      commit: data.commit ?? false,\n      sample_rate: data.sampleRate ?? this.currentSampleRate,\n      previous_text: data.previousText,\n    };\n\n    this.websocket.send(JSON.stringify(message));\n  }\n\n  /**\n   * Commits the transcription, signaling that a segment of audio has been sent. This clears the buffer and triggers a COMMITTED_TRANSCRIPT event. Context from previous segments is kept.\n   * Committing a segment triggers a COMMITTED_TRANSCRIPT event.\n   *\n   * @throws {Error} If the WebSocket connection is not open\n   *\n   * @remarks\n   * Only needed when using CommitStrategy.MANUAL.\n   * When using CommitStrategy.VAD, commits are handled automatically by the server.\n   *\n   * @example\n   * ```typescript\n   * // Send all audio chunks\n   * for (const chunk of audioChunks) {\n   *     connection.send({ audioBase64: chunk });\n   * }\n   *\n   * // Finalize the transcription\n   * connection.commit();\n   * ```\n   */\n  public commit(): void {\n    if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) {\n      throw new Error(\"WebSocket is not connected\");\n    }\n\n    const message: InputAudioChunk = {\n      message_type: \"input_audio_chunk\",\n      audio_base_64: \"\",\n      commit: true,\n      sample_rate: this.currentSampleRate,\n    };\n\n    this.websocket.send(JSON.stringify(message));\n  }\n\n  /**\n   * Closes the WebSocket connection and cleans up resources.\n   * This will terminate any ongoing transcription and stop microphone streaming if active.\n   *\n   * @remarks\n   * After calling close(), this connection cannot be reused.\n   * Create a new connection if you need to start transcribing again.\n   *\n   * @example\n   * ```typescript\n   * connection.on(RealtimeEvents.COMMITTED_TRANSCRIPT, (data) => {\n   *     console.log(\"Segment committed:\", data.transcript);\n   *     connection.close();\n   * });\n   * ```\n   */\n  public close(): void {\n    // Cleanup audio resources (microphone stream, audio context)\n    if (this._audioCleanup) {\n      this._audioCleanup();\n    }\n\n    // Close WebSocket connection\n    if (this.websocket) {\n      this.websocket.close(1000, \"User ended session\");\n    }\n  }\n}\n","import { RealtimeConnection } from \"./connection\";\nimport { loadScribeAudioProcessor } from \"../utils/scribeAudioProcessor.generated\";\n\nexport enum AudioFormat {\n  PCM_8000 = \"pcm_8000\",\n  PCM_16000 = \"pcm_16000\",\n  PCM_22050 = \"pcm_22050\",\n  PCM_24000 = \"pcm_24000\",\n  PCM_44100 = \"pcm_44100\",\n  PCM_48000 = \"pcm_48000\",\n  ULAW_8000 = \"ulaw_8000\",\n}\n\nexport enum CommitStrategy {\n  MANUAL = \"manual\",\n  VAD = \"vad\",\n}\n\ninterface BaseOptions {\n  /**\n   * Token to use for the WebSocket connection. Obtained from the ElevenLabs API.\n   */\n  token: string;\n  /**\n   * Strategy for committing transcriptions.\n   * @default CommitStrategy.MANUAL\n   */\n  commitStrategy?: CommitStrategy;\n  /**\n   * Silence threshold in seconds for VAD (Voice Activity Detection).\n   * Must be a positive number between 0.3 and 3.0\n   */\n  vadSilenceThresholdSecs?: number;\n  /**\n   * Threshold for voice activity detection.\n   * Must be between 0.1 and 0.9.\n   */\n  vadThreshold?: number;\n  /**\n   * Minimum speech duration in milliseconds.\n   * Must be a positive integer between 50 and 2000.\n   */\n  minSpeechDurationMs?: number;\n  /**\n   * Minimum silence duration in milliseconds.\n   * Must be a positive integer between 50 and 2000.\n   */\n  minSilenceDurationMs?: number;\n  /**\n   * Model ID to use for transcription.\n   * Must be a valid model ID.\n   */\n  modelId: string;\n  /**\n   * An ISO-639-1 or ISO-639-3 language_code corresponding to the language of the audio file.\n   * Can sometimes improve transcription performance if known beforehand.\n   */\n  languageCode?: string;\n  /**\n   * Base URI to use for the WebSocket connection.\n   * If not provided, the default URI will be used.\n   */\n  baseUri?: string;\n  /**\n   * Whether to receive a committed_transcript_with_timestamps event which includes word-level timestamps.\n   * @default false\n   */\n  includeTimestamps?: boolean;\n}\n\nexport interface AudioOptions extends BaseOptions {\n  audioFormat: AudioFormat;\n  sampleRate: number;\n  microphone?: never;\n}\n\n/**\n * Options for automatic microphone streaming in the browser.\n */\nexport interface MicrophoneOptions extends BaseOptions {\n  microphone?: {\n    deviceId?: ConstrainDOMString;\n    echoCancellation?: boolean;\n    noiseSuppression?: boolean;\n    autoGainControl?: boolean;\n    channelCount?: number;\n  };\n  audioFormat?: never;\n  sampleRate?: never;\n}\n\n/**\n * Real-time speech-to-text transcription client for browser environments.\n * Supports microphone streaming and manual audio chunk transmission.\n */\n\n// biome-ignore lint/complexity/noStaticOnlyClass: This class is static only because it is a singleton\nexport class ScribeRealtime {\n  private static readonly DEFAULT_BASE_URI = \"wss://api.elevenlabs.io\";\n\n  private static getWebSocketUri(\n    baseUri: string = ScribeRealtime.DEFAULT_BASE_URI\n  ): string {\n    return `${baseUri}/v1/speech-to-text/realtime`;\n  }\n\n  private static buildWebSocketUri(\n    options: AudioOptions | MicrophoneOptions\n  ): string {\n    const baseUri = ScribeRealtime.getWebSocketUri(options.baseUri);\n    const params = new URLSearchParams();\n\n    // Model ID and token are required, so no check required\n    params.append(\"model_id\", options.modelId);\n    params.append(\"token\", options.token);\n\n    // Add optional parameters if provided, with validation\n    if (options.commitStrategy !== undefined) {\n      params.append(\"commit_strategy\", options.commitStrategy);\n    }\n    if (options.audioFormat !== undefined) {\n      params.append(\"audio_format\", options.audioFormat);\n    }\n    if (options.vadSilenceThresholdSecs !== undefined) {\n      if (\n        options.vadSilenceThresholdSecs <= 0.3 ||\n        options.vadSilenceThresholdSecs > 3.0\n      ) {\n        throw new Error(\"vadSilenceThresholdSecs must be between 0.3 and 3.0\");\n      }\n      params.append(\n        \"vad_silence_threshold_secs\",\n        options.vadSilenceThresholdSecs.toString()\n      );\n    }\n    if (options.vadThreshold !== undefined) {\n      if (options.vadThreshold < 0.1 || options.vadThreshold > 0.9) {\n        throw new Error(\"vadThreshold must be between 0.1 and 0.9\");\n      }\n      params.append(\"vad_threshold\", options.vadThreshold.toString());\n    }\n    if (options.minSpeechDurationMs !== undefined) {\n      if (\n        options.minSpeechDurationMs <= 50 ||\n        options.minSpeechDurationMs > 2000\n      ) {\n        throw new Error(\"minSpeechDurationMs must be between 50 and 2000\");\n      }\n      params.append(\n        \"min_speech_duration_ms\",\n        options.minSpeechDurationMs.toString()\n      );\n    }\n    if (options.minSilenceDurationMs !== undefined) {\n      if (\n        options.minSilenceDurationMs <= 50 ||\n        options.minSilenceDurationMs > 2000\n      ) {\n        throw new Error(\"minSilenceDurationMs must be between 50 and 2000\");\n      }\n      params.append(\n        \"min_silence_duration_ms\",\n        options.minSilenceDurationMs.toString()\n      );\n    }\n    if (options.languageCode !== undefined) {\n      params.append(\"language_code\", options.languageCode);\n    }\n    if (options.includeTimestamps !== undefined) {\n      params.append(\n        \"include_timestamps\",\n        options.includeTimestamps ? \"true\" : \"false\"\n      );\n    }\n\n    const queryString = params.toString();\n    return queryString ? `${baseUri}?${queryString}` : baseUri;\n  }\n\n  /**\n   * Establishes a WebSocket connection for real-time speech-to-text transcription.\n   *\n   * @param options - Configuration options for the connection\n   * @returns A RealtimeConnection instance\n   *\n   * @example\n   * ```typescript\n   * // Manual audio streaming\n   * const connection = Scribe.connect({\n   *     token: \"...\",\n   *     modelId: \"scribe_v2_realtime\",\n   *     audioFormat: AudioFormat.PCM_16000,\n   *     sampleRate: 16000,\n   * });\n   *\n   * // Automatic microphone streaming\n   * const connection = Scribe.connect({\n   *     token: \"...\",\n   *     modelId: \"scribe_v2_realtime\",\n   *     microphone: {\n   *         echoCancellation: true,\n   *         noiseSuppression: true\n   *     }\n   * });\n   * ```\n   */\n  public static connect(\n    options: AudioOptions | MicrophoneOptions\n  ): RealtimeConnection {\n    if (!options.modelId) {\n      throw new Error(\"modelId is required\");\n    }\n\n    // Create connection object first so users can attach event listeners before messages arrive\n    const sampleRate =\n      \"microphone\" in options && options.microphone\n        ? 16000\n        : (options as AudioOptions).sampleRate;\n    const connection = new RealtimeConnection(sampleRate);\n\n    // Build WebSocket URI with query parameters\n    const uri = ScribeRealtime.buildWebSocketUri(options);\n\n    const websocket = new WebSocket(uri);\n\n    // If microphone mode, set up streaming handler\n    if (\"microphone\" in options && options.microphone) {\n      websocket.addEventListener(\"open\", () => {\n        ScribeRealtime.streamFromMicrophone(\n          options as MicrophoneOptions,\n          connection\n        );\n      });\n    }\n\n    connection.setWebSocket(websocket);\n\n    return connection;\n  }\n\n  private static async streamFromMicrophone(\n    options: MicrophoneOptions,\n    connection: RealtimeConnection\n  ): Promise<void> {\n    const TARGET_SAMPLE_RATE = 16000;\n\n    try {\n      // Get microphone access\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          deviceId: options.microphone?.deviceId,\n          echoCancellation: options.microphone?.echoCancellation ?? true,\n          noiseSuppression: options.microphone?.noiseSuppression ?? true,\n          autoGainControl: options.microphone?.autoGainControl ?? true,\n          channelCount: options.microphone?.channelCount ?? 1,\n          sampleRate: { ideal: TARGET_SAMPLE_RATE },\n        },\n      });\n\n      // Get the actual sample rate from the stream - the ideal may not have been honored\n      const trackSettings = stream.getAudioTracks()[0]?.getSettings();\n      const streamSampleRate = trackSettings?.sampleRate;\n\n      // Create audio context matching the stream's sample rate to avoid Firefox errors\n      // Firefox requires the AudioContext to match the microphone's native sample rate\n      const audioContext = new AudioContext(\n        streamSampleRate ? { sampleRate: streamSampleRate } : {}\n      );\n\n      // Load scribe worklet\n      await loadScribeAudioProcessor(audioContext.audioWorklet);\n\n      // Set up audio pipeline\n      const source = audioContext.createMediaStreamSource(stream);\n      const scribeNode = new AudioWorkletNode(\n        audioContext,\n        \"scribeAudioProcessor\"\n      );\n\n      // Configure the worklet with sample rate info for resampling\n      // (only needed when AudioContext sample rate differs from target)\n      if (audioContext.sampleRate !== TARGET_SAMPLE_RATE) {\n        scribeNode.port.postMessage({\n          type: \"configure\",\n          inputSampleRate: audioContext.sampleRate,\n          outputSampleRate: TARGET_SAMPLE_RATE,\n        });\n      }\n\n      // Handle audio data from worklet\n      scribeNode.port.onmessage = event => {\n        const { audioData } = event.data;\n        // Convert ArrayBuffer to base64\n        const bytes = new Uint8Array(audioData);\n        let binary = \"\";\n        for (let i = 0; i < bytes.length; i++) {\n          binary += String.fromCharCode(bytes[i]);\n        }\n        const base64Audio = btoa(binary);\n\n        connection.send({ audioBase64: base64Audio });\n      };\n\n      // Connect audio pipeline\n      source.connect(scribeNode);\n\n      // Resume audio context if needed\n      if (audioContext.state === \"suspended\") {\n        await audioContext.resume();\n      }\n\n      // Store cleanup function\n      connection._audioCleanup = () => {\n        stream.getTracks().forEach(track => {\n          track.stop();\n        });\n        source.disconnect();\n        scribeNode.disconnect();\n        audioContext.close();\n      };\n    } catch (error) {\n      console.error(\"Failed to start microphone streaming:\", error);\n      throw error;\n    }\n  }\n}\n","// AUTO-GENERATED BY packages/client/scripts/generateWorklets.js\nimport { createWorkletModuleLoader } from \"./createWorkletModuleLoader\";\n\nexport const loadScribeAudioProcessor = createWorkletModuleLoader(\n  \"scribeAudioProcessor\",\n  // language=JavaScript\n  `/*\n * Scribe Audio Processor for converting microphone audio to PCM16 format\n * Supports resampling for browsers like Firefox that don't support\n * AudioContext sample rate constraints.\n * USED BY @elevenlabs/client\n */\n\nclass ScribeAudioProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n    this.buffer = [];\n    this.bufferSize = 4096; // Buffer size for optimal chunk transmission\n\n    // Resampling state\n    this.inputSampleRate = null;\n    this.outputSampleRate = null;\n    this.resampleRatio = 1;\n    this.lastSample = 0;\n    this.resampleAccumulator = 0;\n\n    this.port.onmessage = ({ data }) => {\n      if (data.type === \"configure\") {\n        this.inputSampleRate = data.inputSampleRate;\n        this.outputSampleRate = data.outputSampleRate;\n        if (this.inputSampleRate && this.outputSampleRate) {\n          this.resampleRatio = this.inputSampleRate / this.outputSampleRate;\n        }\n      }\n    };\n  }\n\n  // Linear interpolation resampling\n  resample(inputData) {\n    if (this.resampleRatio === 1 || !this.inputSampleRate) {\n      return inputData;\n    }\n\n    const outputSamples = [];\n\n    for (let i = 0; i < inputData.length; i++) {\n      const currentSample = inputData[i];\n\n      // Generate output samples using linear interpolation\n      while (this.resampleAccumulator < 1) {\n        const interpolated =\n          this.lastSample +\n          (currentSample - this.lastSample) * this.resampleAccumulator;\n        outputSamples.push(interpolated);\n        this.resampleAccumulator += this.resampleRatio;\n      }\n\n      this.resampleAccumulator -= 1;\n      this.lastSample = currentSample;\n    }\n\n    return new Float32Array(outputSamples);\n  }\n\n  process(inputs) {\n    const input = inputs[0];\n    if (input.length > 0) {\n      let channelData = input[0]; // Get first channel (mono)\n\n      // Resample if needed (for Firefox and other browsers that don't\n      // support AudioContext sample rate constraints)\n      if (this.resampleRatio !== 1) {\n        channelData = this.resample(channelData);\n      }\n\n      // Add incoming audio to buffer\n      for (let i = 0; i < channelData.length; i++) {\n        this.buffer.push(channelData[i]);\n      }\n\n      // When buffer reaches threshold, convert and send\n      if (this.buffer.length >= this.bufferSize) {\n        const float32Array = new Float32Array(this.buffer);\n        const int16Array = new Int16Array(float32Array.length);\n\n        // Convert Float32 [-1, 1] to Int16 [-32768, 32767]\n        for (let i = 0; i < float32Array.length; i++) {\n          // Clamp the value to prevent overflow\n          const sample = Math.max(-1, Math.min(1, float32Array[i]));\n          // Scale to PCM16 range\n          int16Array[i] = sample < 0 ? sample * 32768 : sample * 32767;\n        }\n\n        // Send to main thread as transferable ArrayBuffer\n        this.port.postMessage(\n          {\n            audioData: int16Array.buffer\n          },\n          [int16Array.buffer]\n        );\n\n        // Clear buffer\n        this.buffer = [];\n      }\n    }\n\n    return true; // Continue processing\n  }\n}\n\nregisterProcessor(\"scribeAudioProcessor\", ScribeAudioProcessor);\n\n`\n);\n","import { BaseConversation, type PartialOptions } from \"./BaseConversation\";\nimport { TextConversation } from \"./TextConversation\";\nimport { VoiceConversation } from \"./VoiceConversation\";\n\nexport type {\n  Mode,\n  Role,\n  Options,\n  PartialOptions,\n  ClientToolsConfig,\n  Callbacks,\n  Status,\n  AudioWorkletConfig,\n} from \"./BaseConversation\";\nexport type { InputConfig } from \"./utils/input\";\nexport type { OutputConfig } from \"./utils/output\";\nexport { Input } from \"./utils/input\";\nexport { Output } from \"./utils/output\";\nexport type {\n  IncomingSocketEvent,\n  VadScoreEvent,\n  AudioAlignmentEvent,\n} from \"./utils/events\";\nexport type {\n  SessionConfig,\n  BaseSessionConfig,\n  DisconnectionDetails,\n  Language,\n  ConnectionType,\n  FormatConfig,\n} from \"./utils/BaseConnection\";\nexport { createConnection } from \"./utils/ConnectionFactory\";\nexport { WebSocketConnection } from \"./utils/WebSocketConnection\";\nexport { WebRTCConnection } from \"./utils/WebRTCConnection\";\nexport { postOverallFeedback } from \"./utils/postOverallFeedback\";\nexport { SessionConnectionError } from \"./utils/errors\";\nexport { VoiceConversation } from \"./VoiceConversation\";\nexport { TextConversation } from \"./TextConversation\";\n\n// Scribe exports\nexport {\n  Scribe,\n  AudioFormat,\n  CommitStrategy,\n  RealtimeEvents,\n  RealtimeConnection,\n} from \"./scribe\";\nexport type {\n  AudioOptions,\n  MicrophoneOptions,\n  WebSocketMessage,\n  PartialTranscriptMessage,\n  CommittedTranscriptMessage,\n  CommittedTranscriptWithTimestampsMessage,\n  ScribeErrorMessage,\n  ScribeAuthErrorMessage,\n  ScribeQuotaExceededErrorMessage,\n  ScribeCommitThrottledErrorMessage,\n  ScribeTranscriberErrorMessage,\n  ScribeUnacceptedTermsErrorMessage,\n  ScribeRateLimitedErrorMessage,\n  ScribeInputErrorMessage,\n  ScribeQueueOverflowErrorMessage,\n  ScribeResourceExhaustedErrorMessage,\n  ScribeSessionTimeLimitExceededErrorMessage,\n  ScribeChunkSizeExceededErrorMessage,\n  ScribeInsufficientAudioActivityErrorMessage,\n} from \"./scribe\";\n\nexport class Conversation extends BaseConversation {\n  public static startSession(options: PartialOptions): Promise<Conversation> {\n    const fullOptions = Conversation.getFullOptions(options);\n    return fullOptions.textOnly\n      ? TextConversation.startSession(fullOptions)\n      : VoiceConversation.startSession(fullOptions);\n  }\n}\n","const HTTPS_API_ORIGIN = \"https://api.elevenlabs.io\";\n\nexport interface RatingFeedback {\n  rating: number;\n  comment?: string;\n}\n\ntype Feedback = RatingFeedback;\n\nexport function postOverallFeedback(\n  conversationId: string,\n  like: boolean,\n  origin?: string\n): Promise<Response>;\nexport function postOverallFeedback(\n  conversationId: string,\n  feedback: Feedback,\n  origin?: string\n): Promise<Response>;\nexport function postOverallFeedback(\n  conversationId: string,\n  likeOrFeedback: boolean | Feedback,\n  origin: string = HTTPS_API_ORIGIN\n): Promise<Response> {\n  const body: {\n    feedback?: \"like\" | \"dislike\";\n    rating?: number;\n    comment?: string;\n  } = {};\n\n  if (typeof likeOrFeedback === \"boolean\") {\n    body.feedback = likeOrFeedback ? \"like\" : \"dislike\";\n  } else {\n    body.rating = likeOrFeedback.rating;\n    body.comment = likeOrFeedback.comment;\n  }\n\n  return fetch(`${origin}/v1/convai/conversations/${conversationId}/feedback`, {\n    method: \"POST\",\n    body: JSON.stringify(body),\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  });\n}\n"],"names":["EMPTY_FREQUENCY_DATA","Uint8Array","BaseConversation","options","connection","_this3","_this","this","_this2","lastInterruptTimestamp","mode","status","volume","currentEventId","lastFeedbackEventId","canSendFeedback","endSessionWithDetails","details","Promise","resolve","updateStatus","handleEndSession","then","onDisconnect","e","reject","onMessage","parsedEvent","type","handleInterruption","handleAgentResponse","handleUserTranscript","handleTentativeAgentResponse","_temp","_catch","handleClientToolCall","error","onError","Error","message","String","clientToolName","client_tool_call","tool_name","toolCallId","tool_call_id","handleAudio","handleVadScore","sendMessage","event_id","ping_event","handleMCPToolCall","handleMCPConnectionStatus","handleAgentToolRequest","handleAgentToolResponse","handleConversationMetadata","handleAsrInitiationMetadata","handleAgentChatResponsePart","handleErrorEvent","onDebug","setVolume","_ref2","onConnect","conversationId","onModeChange","updateMode","getFullOptions","partialOptions","_partialOptions$overr","textOnly","_options$overrides$co","_options$overrides","textOnlyOverride","overrides","conversation","console","warn","isTextOnly","_extends","clientTools","onAudio","onStatusChange","onCanSendFeedbackChange","onInterruption","_proto","prototype","endSession","reason","close","updateCanSendFeedback","event","interruption_event","source","role","agent_response_event","agent_response","user_transcription_event","user_transcript","response","tentative_agent_response_internal_event","tentative_agent_response","onVadScore","vadScore","vad_score_event","vad_score","_this5","Object","hasOwnProperty","call","_temp2","parameters","result","formattedResult","JSON","stringify","is_error","onUnhandledClientToolCall","onMCPToolCall","mcp_tool_call","onMCPConnectionStatus","mcp_connection_status","onAgentToolRequest","agent_tool_request","agent_tool_response","context","CloseEvent","onAgentToolResponse","onConversationMetadata","conversation_initiation_metadata_event","onAsrInitiationMetadata","asr_initiation_metadata_event","onAgentChatResponsePart","text_response_part","errorType","error_event","error_type","code","debugMessage","debug_message","Event","getId","isOpen","setMicMuted","isMuted","getInputByteFrequencyData","getOutputByteFrequencyData","getInputVolume","getOutputVolume","sendFeedback","like","score","sendContextualUpdate","text","sendUserMessage","sendUserActivity","sendMCPToolApprovalResult","isApproved","is_approved","BaseConnection","config","queue","disconnectionDetails","onDisconnectCallback","onMessageCallback","onModeChangeCallback","debug","info","callback","length","queueMicrotask","forEach","_this$onModeChangeCal","disconnect","_this$onDisconnectCal","handleMessage","push","parseFormat","format","_format$split","split","formatPart","sampleRatePart","includes","sampleRate","Number","parseInt","isNaN","PACKAGE_VERSION","isValidSocketEvent","CONVERSATION_INITIATION_CLIENT_DATA_TYPE","constructOverrides","_config$overrides","_config$overrides$age","_config$overrides$age2","_config$overrides$age3","_config$overrides$tts","_config$overrides$tts2","_config$overrides$tts3","_config$overrides$tts4","_config$overrides$con","overridesEvent","conversation_config_override","agent","prompt","first_message","firstMessage","language","tts","voice_id","voiceId","speed","stability","similarity_boost","similarityBoost","text_only","customLlmExtraBody","custom_llm_extra_body","dynamicVariables","dynamic_variables","userId","user_id","client","source_info","version","SessionConnectionError","_Error","closeCode","closeReason","name","_inheritsLoose","_wrapNativeSuper","WebSocketConnection","_BaseConnection","socket","inputFormat","outputFormat","addEventListener","setTimeout","undefined","parse","data","create","_config$origin","_config$overrides2","url","origin","signedUrl","separator","agentId","protocols","authorization","WebSocket","_socket","send","once","conversationConfig","conversation_id","agent_output_audio_format","user_input_audio_format","_socket2","arrayBufferToBase64","b","buffer","window","btoa","fromCharCode","apply","base64ToArrayBuffer","base64","binaryString","atob","len","bytes","i","charCodeAt","URLCache","Map","createWorkletModuleLoader","sourceCode","worklet","path","_exit","_temp4","_result","_exit2","_result2","moduleURL","addModule","set","blob","Blob","blobURL","URL","createObjectURL","revokeObjectURL","cachedUrl","get","_temp3","loadRawAudioProcessor","WebRTCConnection","room","isConnected","audioEventId","audioCaptureContext","audioElements","outputDeviceId","outputAnalyser","outputFrequencyData","setupRoomEventListeners","conversationToken","_result3","Room","Date","now","connect","livekitUrl","onConnected","off","RoomEvent","Connected","on","_room$name$match","match","localParticipant","setMicrophoneEnabled","replace","convertWssToHttps","fetch","ok","statusText","json","token","msg","_this4","Disconnected","toString","ConnectionStateChanged","state","ConnectionState","DataReceived","payload","_participant","TextDecoder","decode","TrackSubscribed","track","_publication","participant","_temp8","kind","Track","Kind","Audio","identity","_temp7","audioElement","style","display","document","body","appendChild","setupAudioCapture","remoteAudioTrack","attach","autoplay","controls","_temp6","setSinkId","_temp5","ActiveSpeakersChanged","speakers","startsWith","ParticipantDisconnected","_participant$identity","audioTrackPublications","publication","stop","element","parentNode","removeChild","_this6","_temp9","TextEncoder","encode","publishData","reliable","getRoom","_this7","micTrackPublication","getTrackPublication","Source","Microphone","_temp0","mute","unmute","_this8","_temp1","audioContext","AudioContext","createAnalyser","fftSize","smoothingTimeConstant","mediaStream","MediaStream","mediaStreamTrack","createMediaStreamSource","audioWorklet","AudioWorkletNode","port","postMessage","onmessage","_event$data","base64Audio","eventId","audio_event","audio_base_64","setAudioVolume","setAudioOutputDevice","deviceId","_this9","HTMLAudioElement","promises","map","all","setAudioInputDevice","_this0","_temp11","createLocalAudioTrack","exact","echoCancellation","noiseSuppression","autoGainControl","channelCount","ideal","audioTrack","publishTrack","currentMicTrackPublication","_temp10","unpublishTrack","_temp13","_temp12","recoveryError","frequencyBinCount","getByteFrequencyData","createConnection","connectionType","determineConnectionType","isIosDevice","navigator","platform","userAgent","applyDelay","delayConfig","default","android","_delayConfig$android","delay","test","_delayConfig$ios","ios","TextConversation","_BaseConversation","arguments","startSession","fullOptions","connectionDelay","_createConnection","_connection","defaultConstraints","Input","analyser","inputStream","mediaStreamSource","permissions","settingInput","handlePermissionsChange","_track$getSettings","getAudioTracks","_ref","getSettings","setInputDevice","preferHeadphonesForIosDevices","inputDeviceId","workletPaths","libsampleratePath","constraints","voiceIsolation","mediaDevices","getUserMedia","audio","_navigator$mediaDevic","resume","query","getDeviceIdConstraint","supportsSampleRateConstraint","getSupportedConstraints","enumerateDevices","availableDevices","idealDevice","find","d","keyword","label","toLowerCase","_inputStream","_context","getTracks","forgetInputStreamAndSource","_iterator","_step","_createForOfIteratorHelperLoose","done","value","removeEventListener","setMuted","newInputStream","_finallyRethrows","_wasThrown","loadAudioConcatProcessor","Output","gain","createGain","src","load","destination","createMediaStreamDestination","srcObject","stream","_audioElement","_audioElement2","pause","setOutputDevice","RealtimeEvents","VoiceConversation","input","output","wakeLock","inputFrequencyData","visibilityChangeHandler","onInputWorkletMessage","user_audio_chunk","onOutputWorkletMessage","finished","addAudioBase64Chunk","chunk","cancelScheduledValues","currentTime","fadeOutAudio","exponentialRampToValueAtTime","calculateVolume","frequencyData","clampedVolume","isFinite","Math","min","max","_this$wakeLock","visibilityState","released","requestWakeLock","lock","request","_await$navigator$wake","_options$useWakeLock","preliminaryInputStream","_Promise$all","_preliminaryInputStre","_preliminaryInputStre2","_input","_output","_wakeLock","release","useWakeLock","_VoiceConversation$re","_this2$wakeLock","_this$options$onAudio","_this$options","alignment","onAudioAlignment","changeInputDevice","_ref3","_result4","newInput","_this3$input","changeOutputDevice","_ref4","_exit3","_result6","newOutput","_this4$output","EventEmitter","listeners","listener","has","Set","eventListeners","add","emit","_arguments","slice","AudioFormat","CommitStrategy","RealtimeConnection","websocket","eventEmitter","currentSampleRate","_audioCleanup","_proto2","setWebSocket","readyState","OPEN","message_type","SESSION_STARTED","PARTIAL_TRANSCRIPT","COMMITTED_TRANSCRIPT","COMMITTED_TRANSCRIPT_WITH_TIMESTAMPS","AUTH_ERROR","ERROR","QUOTA_EXCEEDED","COMMIT_THROTTLED","TRANSCRIBER_ERROR","UNACCEPTED_TERMS","RATE_LIMITED","INPUT_ERROR","QUEUE_OVERFLOW","RESOURCE_EXHAUSTED","SESSION_TIME_LIMIT_EXCEEDED","CHUNK_SIZE_EXCEEDED","INSUFFICIENT_AUDIO_ACTIVITY","log","wasClean","errorMessage","CLOSE","_data$commit","_data$sampleRate","audioBase64","commit","sample_rate","previous_text","previousText","loadScribeAudioProcessor","ScribeRealtime","getWebSocketUri","baseUri","DEFAULT_BASE_URI","buildWebSocketUri","params","URLSearchParams","append","modelId","commitStrategy","audioFormat","vadSilenceThresholdSecs","vadThreshold","minSpeechDurationMs","minSilenceDurationMs","languageCode","includeTimestamps","queryString","microphone","uri","streamFromMicrophone","TARGET_SAMPLE_RATE","_options$microphone","_options$microphone$e","_options$microphone2","_options$microphone$n","_options$microphone3","_options$microphone$a","_options$microphone4","_options$microphone$c","_options$microphone5","_stream$getAudioTrack","trackSettings","streamSampleRate","scribeNode","inputSampleRate","outputSampleRate","audioData","binary","Conversation","likeOrFeedback","feedback","rating","comment","method","headers"],"mappings":"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"}