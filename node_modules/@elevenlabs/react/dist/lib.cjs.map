{"version":3,"file":"lib.cjs","sources":["../src/index.ts","../src/version.ts","../src/scribe.ts"],"sourcesContent":["import { useEffect, useRef, useState } from \"react\";\nimport {\n  Conversation,\n  type SessionConfig,\n  type Options,\n  type ClientToolsConfig,\n  type InputConfig,\n  type AudioWorkletConfig,\n  type OutputConfig,\n  type FormatConfig,\n  type Mode,\n  type Status,\n  type Callbacks,\n} from \"@elevenlabs/client\";\n\n// Device configuration types for audio device switching\nexport type DeviceFormatConfig = {\n  format: \"pcm\" | \"ulaw\";\n  sampleRate: number;\n  outputDeviceId?: string;\n};\n\nexport type DeviceInputConfig = {\n  preferHeadphonesForIosDevices?: boolean;\n  inputDeviceId?: string;\n};\n\nimport { PACKAGE_VERSION } from \"./version\";\n\nexport type Location = \"us\" | \"global\" | \"eu-residency\" | \"in-residency\";\n\nexport function parseLocation(location: string = \"us\"): Location {\n  switch (location) {\n    case \"eu-residency\":\n    case \"in-residency\":\n    case \"us\":\n    case \"global\":\n      return location;\n    default:\n      console.warn(\n        `[ConversationalAI] Invalid server-location: ${location}. Defaulting to \"us\"`\n      );\n      return \"us\";\n  }\n}\n\nexport function getOriginForLocation(location: Location): string {\n  const originMap: Record<Location, string> = {\n    us: \"wss://api.elevenlabs.io\",\n    \"eu-residency\": \"wss://api.eu.residency.elevenlabs.io\",\n    \"in-residency\": \"wss://api.in.residency.elevenlabs.io\",\n    global: \"wss://api.elevenlabs.io\",\n  };\n\n  return originMap[location];\n}\n\nexport function getLivekitUrlForLocation(location: Location): string {\n  const livekitUrlMap: Record<Location, string> = {\n    us: \"wss://livekit.rtc.elevenlabs.io\",\n    \"eu-residency\": \"wss://livekit.rtc.eu.residency.elevenlabs.io\",\n    \"in-residency\": \"wss://livekit.rtc.in.residency.elevenlabs.io\",\n    global: \"wss://livekit.rtc.elevenlabs.io\",\n  };\n\n  return livekitUrlMap[location];\n}\n\nexport type {\n  Role,\n  Mode,\n  Status,\n  SessionConfig,\n  DisconnectionDetails,\n  Language,\n  VadScoreEvent,\n  AudioAlignmentEvent,\n  InputConfig,\n  FormatConfig,\n  VoiceConversation,\n  TextConversation,\n  Callbacks,\n} from \"@elevenlabs/client\";\nexport { postOverallFeedback } from \"@elevenlabs/client\";\n\n// Scribe exports\nexport {\n  useScribe,\n  AudioFormat,\n  CommitStrategy,\n  RealtimeEvents,\n} from \"./scribe\";\nexport type {\n  ScribeStatus,\n  TranscriptSegment,\n  WordTimestamp,\n  ScribeCallbacks,\n  ScribeHookOptions,\n  UseScribeReturn,\n  RealtimeConnection,\n} from \"./scribe\";\n\nexport type HookOptions = Partial<\n  SessionConfig &\n    HookCallbacks &\n    ClientToolsConfig &\n    InputConfig &\n    OutputConfig &\n    AudioWorkletConfig &\n    FormatConfig & {\n      serverLocation?: Location | string;\n    }\n>;\nexport type ControlledState = {\n  micMuted?: boolean;\n  volume?: number;\n};\nexport type HookCallbacks = Pick<\n  Callbacks,\n  | \"onConnect\"\n  | \"onDisconnect\"\n  | \"onError\"\n  | \"onMessage\"\n  | \"onAudio\"\n  | \"onModeChange\"\n  | \"onStatusChange\"\n  | \"onCanSendFeedbackChange\"\n  | \"onDebug\"\n  | \"onUnhandledClientToolCall\"\n  | \"onVadScore\"\n  | \"onInterruption\"\n  | \"onAgentToolResponse\"\n  | \"onAgentToolRequest\"\n  | \"onConversationMetadata\"\n  | \"onMCPToolCall\"\n  | \"onMCPConnectionStatus\"\n  | \"onAsrInitiationMetadata\"\n  | \"onAgentChatResponsePart\"\n  | \"onAudioAlignment\"\n>;\n\nexport function useConversation<T extends HookOptions & ControlledState>(\n  props: T = {} as T\n) {\n  const { micMuted, volume, serverLocation, ...defaultOptions } = props;\n  const conversationRef = useRef<Conversation | null>(null);\n  const lockRef = useRef<Promise<Conversation> | null>(null);\n  const shouldEndRef = useRef(false);\n  const [status, setStatus] = useState<Status>(\"disconnected\");\n  const [canSendFeedback, setCanSendFeedback] = useState(false);\n  const [mode, setMode] = useState<Mode>(\"listening\");\n\n  const micMutedRef = useRef<boolean | undefined>(micMuted);\n  const volumeRef = useRef<number | undefined>(volume);\n\n  micMutedRef.current = micMuted;\n  volumeRef.current = volume;\n\n  useEffect(() => {\n    if (micMuted !== undefined) {\n      conversationRef?.current?.setMicMuted(micMuted);\n    }\n  }, [micMuted]);\n\n  useEffect(() => {\n    if (volume !== undefined) {\n      conversationRef?.current?.setVolume({ volume });\n    }\n  }, [volume]);\n\n  useEffect(() => {\n    return () => {\n      shouldEndRef.current = true;\n      if (lockRef.current) {\n        lockRef.current.then(conv => conv.endSession());\n      } else {\n        conversationRef.current?.endSession();\n      }\n    };\n  }, []);\n\n  return {\n    startSession: (async (options?: HookOptions) => {\n      if (conversationRef.current?.isOpen()) {\n        return conversationRef.current.getId();\n      }\n\n      if (lockRef.current) {\n        const conversation = await lockRef.current;\n        return conversation.getId();\n      }\n\n      shouldEndRef.current = false;\n\n      try {\n        const resolvedServerLocation = parseLocation(\n          options?.serverLocation || serverLocation\n        );\n        const origin = getOriginForLocation(resolvedServerLocation);\n        const calculatedLivekitUrl = getLivekitUrlForLocation(\n          resolvedServerLocation\n        );\n\n        lockRef.current = Conversation.startSession({\n          ...(defaultOptions ?? {}),\n          ...(options ?? {}),\n          origin,\n\n          livekitUrl:\n            options?.livekitUrl ||\n            defaultOptions?.livekitUrl ||\n            calculatedLivekitUrl,\n          overrides: {\n            ...(defaultOptions?.overrides ?? {}),\n            ...(options?.overrides ?? {}),\n            client: {\n              ...(defaultOptions?.overrides?.client ?? {}),\n              ...(options?.overrides?.client ?? {}),\n              source:\n                options?.overrides?.client?.source ||\n                defaultOptions?.overrides?.client?.source ||\n                \"react_sdk\",\n              version:\n                options?.overrides?.client?.version ||\n                defaultOptions?.overrides?.client?.version ||\n                PACKAGE_VERSION,\n            },\n          },\n          // Pass through user-provided callbacks\n          onConnect: options?.onConnect || defaultOptions?.onConnect,\n          onDisconnect: options?.onDisconnect || defaultOptions?.onDisconnect,\n          onError: options?.onError || defaultOptions?.onError,\n          onMessage: options?.onMessage || defaultOptions?.onMessage,\n          onAudio: options?.onAudio || defaultOptions?.onAudio,\n          onDebug: options?.onDebug || defaultOptions?.onDebug,\n          onUnhandledClientToolCall:\n            options?.onUnhandledClientToolCall ||\n            defaultOptions?.onUnhandledClientToolCall,\n          onVadScore: options?.onVadScore || defaultOptions?.onVadScore,\n          onInterruption:\n            options?.onInterruption || defaultOptions?.onInterruption,\n          onAgentToolRequest:\n            options?.onAgentToolRequest || defaultOptions?.onAgentToolRequest,\n          onAgentToolResponse:\n            options?.onAgentToolResponse || defaultOptions?.onAgentToolResponse,\n          onConversationMetadata:\n            options?.onConversationMetadata ||\n            defaultOptions?.onConversationMetadata,\n          onMCPToolCall:\n            options?.onMCPToolCall || defaultOptions?.onMCPToolCall,\n          onMCPConnectionStatus:\n            options?.onMCPConnectionStatus ||\n            defaultOptions?.onMCPConnectionStatus,\n          onAsrInitiationMetadata:\n            options?.onAsrInitiationMetadata ||\n            defaultOptions?.onAsrInitiationMetadata,\n          onAgentChatResponsePart:\n            options?.onAgentChatResponsePart ||\n            defaultOptions?.onAgentChatResponsePart,\n          onAudioAlignment:\n            options?.onAudioAlignment || defaultOptions?.onAudioAlignment,\n          onModeChange: ({ mode }) => {\n            setMode(mode);\n            (options?.onModeChange || defaultOptions?.onModeChange)?.({ mode });\n          },\n          onStatusChange: ({ status }) => {\n            setStatus(status);\n            (options?.onStatusChange || defaultOptions?.onStatusChange)?.({\n              status,\n            });\n          },\n          onCanSendFeedbackChange: ({ canSendFeedback }) => {\n            setCanSendFeedback(canSendFeedback);\n            (\n              options?.onCanSendFeedbackChange ||\n              defaultOptions?.onCanSendFeedbackChange\n            )?.({ canSendFeedback });\n          },\n        } as Options);\n\n        conversationRef.current = await lockRef.current;\n\n        // Check if session was cancelled while connecting\n        if (shouldEndRef.current) {\n          await conversationRef.current.endSession();\n          conversationRef.current = null;\n          lockRef.current = null;\n          throw new Error(\"Session cancelled during connection\");\n        }\n\n        // Persist controlled state between sessions using refs to get current values\n        if (micMutedRef.current !== undefined) {\n          conversationRef.current.setMicMuted(micMutedRef.current);\n        }\n        if (volumeRef.current !== undefined) {\n          conversationRef.current.setVolume({ volume: volumeRef.current });\n        }\n\n        return conversationRef.current.getId();\n      } finally {\n        lockRef.current = null;\n      }\n    }) as T extends SessionConfig\n      ? (options?: HookOptions) => Promise<string>\n      : (options: SessionConfig & HookOptions) => Promise<string>,\n    endSession: async () => {\n      shouldEndRef.current = true;\n      const pendingConnection = lockRef.current;\n      const conversation = conversationRef.current;\n      conversationRef.current = null;\n\n      if (pendingConnection) {\n        const conv = await pendingConnection;\n        await conv.endSession();\n      } else {\n        await conversation?.endSession();\n      }\n    },\n    setVolume: ({ volume }: { volume: number }) => {\n      conversationRef.current?.setVolume({ volume });\n    },\n    getInputByteFrequencyData: () => {\n      return conversationRef.current?.getInputByteFrequencyData();\n    },\n    getOutputByteFrequencyData: () => {\n      return conversationRef.current?.getOutputByteFrequencyData();\n    },\n    getInputVolume: () => {\n      return conversationRef.current?.getInputVolume() ?? 0;\n    },\n    getOutputVolume: () => {\n      return conversationRef.current?.getOutputVolume() ?? 0;\n    },\n    sendFeedback: (like: boolean) => {\n      conversationRef.current?.sendFeedback(like);\n    },\n    getId: () => {\n      return conversationRef.current?.getId();\n    },\n    sendContextualUpdate: (text: string) => {\n      conversationRef.current?.sendContextualUpdate(text);\n    },\n    sendUserMessage: (text: string) => {\n      conversationRef.current?.sendUserMessage(text);\n    },\n    sendUserActivity: () => {\n      conversationRef.current?.sendUserActivity();\n    },\n    sendMCPToolApprovalResult: (toolCallId: string, isApproved: boolean) => {\n      conversationRef.current?.sendMCPToolApprovalResult(\n        toolCallId,\n        isApproved\n      );\n    },\n    changeInputDevice: async (\n      config: DeviceFormatConfig & DeviceInputConfig\n    ) => {\n      if (\n        conversationRef.current &&\n        \"changeInputDevice\" in conversationRef.current\n      ) {\n        return await (\n          conversationRef.current as unknown as {\n            changeInputDevice: (config: any) => Promise<any>;\n          }\n        ).changeInputDevice(config);\n      }\n      throw new Error(\n        \"Device switching is only available for voice conversations\"\n      );\n    },\n    changeOutputDevice: async (config: DeviceFormatConfig) => {\n      if (\n        conversationRef.current &&\n        \"changeOutputDevice\" in conversationRef.current\n      ) {\n        return await (\n          conversationRef.current as unknown as {\n            changeOutputDevice: (config: any) => Promise<any>;\n          }\n        ).changeOutputDevice(config);\n      }\n      throw new Error(\n        \"Device switching is only available for voice conversations\"\n      );\n    },\n    status,\n    canSendFeedback,\n    micMuted,\n    isSpeaking: mode === \"speaking\",\n  };\n}\n\n// const con = useConversation({agentId: \"\"})\n","// This file is auto-generated during build\nexport const PACKAGE_VERSION = \"0.14.0\";\n","import { useEffect, useRef, useState, useCallback } from \"react\";\nimport { Scribe, RealtimeEvents } from \"@elevenlabs/client\";\nimport type {\n  RealtimeConnection,\n  AudioOptions,\n  MicrophoneOptions,\n  AudioFormat,\n  CommitStrategy,\n  PartialTranscriptMessage,\n  CommittedTranscriptMessage,\n  CommittedTranscriptWithTimestampsMessage,\n  ScribeErrorMessage,\n  ScribeAuthErrorMessage,\n  ScribeQuotaExceededErrorMessage,\n  ScribeCommitThrottledErrorMessage,\n  ScribeTranscriberErrorMessage,\n  ScribeUnacceptedTermsErrorMessage,\n  ScribeRateLimitedErrorMessage,\n  ScribeInputErrorMessage,\n  ScribeQueueOverflowErrorMessage,\n  ScribeResourceExhaustedErrorMessage,\n  ScribeSessionTimeLimitExceededErrorMessage,\n  ScribeChunkSizeExceededErrorMessage,\n  ScribeInsufficientAudioActivityErrorMessage,\n} from \"@elevenlabs/client\";\n\n// ============= Types =============\n\nexport type ScribeStatus =\n  | \"disconnected\"\n  | \"connecting\"\n  | \"connected\"\n  | \"transcribing\"\n  | \"error\";\n\nexport interface WordTimestamp {\n  text?: string;\n  /** Start time in seconds */\n  start?: number;\n  /** End time in seconds */\n  end?: number;\n  type?: \"word\" | \"spacing\";\n  speaker_id?: string;\n  logprob?: number;\n  characters?: string[];\n}\n\nexport interface TranscriptSegment {\n  id: string;\n  text: string;\n  timestamp: number;\n  isFinal: boolean;\n  /** Word-level timestamps (only present when includeTimestamps is enabled) */\n  words?: WordTimestamp[];\n}\n\nexport interface ScribeCallbacks {\n  onSessionStarted?: () => void;\n  onPartialTranscript?: (data: { text: string }) => void;\n  onCommittedTranscript?: (data: { text: string }) => void;\n  onCommittedTranscriptWithTimestamps?: (data: {\n    text: string;\n    words?: WordTimestamp[];\n  }) => void;\n  /** Called for any error (also called when specific error callbacks fire) */\n  onError?: (error: Error | Event) => void;\n  onAuthError?: (data: { error: string }) => void;\n  onQuotaExceededError?: (data: { error: string }) => void;\n  onCommitThrottledError?: (data: { error: string }) => void;\n  onTranscriberError?: (data: { error: string }) => void;\n  onUnacceptedTermsError?: (data: { error: string }) => void;\n  onRateLimitedError?: (data: { error: string }) => void;\n  onInputError?: (data: { error: string }) => void;\n  onQueueOverflowError?: (data: { error: string }) => void;\n  onResourceExhaustedError?: (data: { error: string }) => void;\n  onSessionTimeLimitExceededError?: (data: { error: string }) => void;\n  onChunkSizeExceededError?: (data: { error: string }) => void;\n  onInsufficientAudioActivityError?: (data: { error: string }) => void;\n\n  onConnect?: () => void;\n  onDisconnect?: () => void;\n}\n\nexport interface ScribeHookOptions extends ScribeCallbacks {\n  // Connection options\n  token?: string;\n  modelId?: string;\n  baseUri?: string;\n\n  // VAD options\n  commitStrategy?: CommitStrategy;\n  vadSilenceThresholdSecs?: number;\n  vadThreshold?: number;\n  minSpeechDurationMs?: number;\n  minSilenceDurationMs?: number;\n  languageCode?: string;\n\n  // Microphone options (for automatic microphone mode)\n  microphone?: {\n    deviceId?: string;\n    echoCancellation?: boolean;\n    noiseSuppression?: boolean;\n    autoGainControl?: boolean;\n    channelCount?: number;\n  };\n\n  // Manual audio options\n  audioFormat?: AudioFormat;\n  sampleRate?: number;\n\n  // Auto-connect on mount\n  autoConnect?: boolean;\n\n  // Include timestamps\n  includeTimestamps?: boolean;\n}\n\nexport interface UseScribeReturn {\n  // State\n  status: ScribeStatus;\n  isConnected: boolean;\n  isTranscribing: boolean;\n  partialTranscript: string;\n  committedTranscripts: TranscriptSegment[];\n  error: string | null;\n\n  // Connection methods\n  connect: (options?: Partial<ScribeHookOptions>) => Promise<void>;\n  disconnect: () => void;\n\n  // Audio methods (for manual mode)\n  sendAudio: (\n    audioBase64: string,\n    options?: { commit?: boolean; sampleRate?: number; previousText?: string }\n  ) => void;\n  commit: () => void;\n\n  // Utility methods\n  clearTranscripts: () => void;\n  getConnection: () => RealtimeConnection | null;\n}\n\n// ============= Hook Implementation =============\n\nexport function useScribe(options: ScribeHookOptions = {}): UseScribeReturn {\n  const {\n    // Callbacks\n    onSessionStarted,\n    onPartialTranscript,\n    onCommittedTranscript,\n    onCommittedTranscriptWithTimestamps,\n    onError,\n    onAuthError,\n    onQuotaExceededError,\n    onCommitThrottledError,\n    onTranscriberError,\n    onUnacceptedTermsError,\n    onRateLimitedError,\n    onInputError,\n    onQueueOverflowError,\n    onResourceExhaustedError,\n    onSessionTimeLimitExceededError,\n    onChunkSizeExceededError,\n    onInsufficientAudioActivityError,\n    onConnect,\n    onDisconnect,\n\n    // Connection options\n    token: defaultToken,\n    modelId: defaultModelId,\n    baseUri: defaultBaseUri,\n    commitStrategy: defaultCommitStrategy,\n    vadSilenceThresholdSecs: defaultVadSilenceThresholdSecs,\n    vadThreshold: defaultVadThreshold,\n    minSpeechDurationMs: defaultMinSpeechDurationMs,\n    minSilenceDurationMs: defaultMinSilenceDurationMs,\n    languageCode: defaultLanguageCode,\n\n    // Mode options\n    microphone: defaultMicrophone,\n    audioFormat: defaultAudioFormat,\n    sampleRate: defaultSampleRate,\n\n    // Auto-connect\n    autoConnect = false,\n\n    // Timestamps\n    includeTimestamps: defaultIncludeTimestamps,\n  } = options;\n\n  const connectionRef = useRef<RealtimeConnection | null>(null);\n\n  const [status, setStatus] = useState<ScribeStatus>(\"disconnected\");\n  const [partialTranscript, setPartialTranscript] = useState<string>(\"\");\n  const [committedTranscripts, setCommittedTranscripts] = useState<\n    TranscriptSegment[]\n  >([]);\n  const [error, setError] = useState<string | null>(null);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      connectionRef.current?.close();\n    };\n  }, []);\n\n  const connect = useCallback(\n    async (runtimeOptions: Partial<ScribeHookOptions> = {}) => {\n      if (connectionRef.current) {\n        console.warn(\"Already connected\");\n        return;\n      }\n\n      try {\n        setStatus(\"connecting\");\n        setError(null);\n\n        // Merge default options with runtime options\n        const token = runtimeOptions.token || defaultToken;\n        const modelId = runtimeOptions.modelId || defaultModelId;\n\n        if (!token) {\n          throw new Error(\"Token is required\");\n        }\n        if (!modelId) {\n          throw new Error(\"Model ID is required\");\n        }\n\n        // Determine mode: microphone or manual\n        const microphone = runtimeOptions.microphone || defaultMicrophone;\n        const audioFormat = runtimeOptions.audioFormat || defaultAudioFormat;\n        const sampleRate = runtimeOptions.sampleRate || defaultSampleRate;\n\n        let connection: RealtimeConnection;\n\n        // Include timestamps if explicitly requested OR if the callback is provided\n        const includeTimestamps =\n          runtimeOptions.includeTimestamps ??\n          defaultIncludeTimestamps ??\n          !!(\n            runtimeOptions.onCommittedTranscriptWithTimestamps ||\n            onCommittedTranscriptWithTimestamps\n          );\n\n        if (microphone) {\n          // Microphone mode\n          connection = Scribe.connect({\n            token,\n            modelId,\n            baseUri: runtimeOptions.baseUri || defaultBaseUri,\n            commitStrategy:\n              runtimeOptions.commitStrategy || defaultCommitStrategy,\n            vadSilenceThresholdSecs:\n              runtimeOptions.vadSilenceThresholdSecs ||\n              defaultVadSilenceThresholdSecs,\n            vadThreshold: runtimeOptions.vadThreshold || defaultVadThreshold,\n            minSpeechDurationMs:\n              runtimeOptions.minSpeechDurationMs || defaultMinSpeechDurationMs,\n            minSilenceDurationMs:\n              runtimeOptions.minSilenceDurationMs ||\n              defaultMinSilenceDurationMs,\n            languageCode: runtimeOptions.languageCode || defaultLanguageCode,\n            microphone,\n            includeTimestamps,\n          } as MicrophoneOptions);\n        } else if (audioFormat && sampleRate) {\n          // Manual audio mode\n          connection = Scribe.connect({\n            token,\n            modelId,\n            baseUri: runtimeOptions.baseUri || defaultBaseUri,\n            commitStrategy:\n              runtimeOptions.commitStrategy || defaultCommitStrategy,\n            vadSilenceThresholdSecs:\n              runtimeOptions.vadSilenceThresholdSecs ||\n              defaultVadSilenceThresholdSecs,\n            vadThreshold: runtimeOptions.vadThreshold || defaultVadThreshold,\n            minSpeechDurationMs:\n              runtimeOptions.minSpeechDurationMs || defaultMinSpeechDurationMs,\n            minSilenceDurationMs:\n              runtimeOptions.minSilenceDurationMs ||\n              defaultMinSilenceDurationMs,\n            languageCode: runtimeOptions.languageCode || defaultLanguageCode,\n            includeTimestamps,\n            audioFormat,\n            sampleRate,\n          } as AudioOptions);\n        } else {\n          throw new Error(\n            \"Either microphone options or (audioFormat + sampleRate) must be provided\"\n          );\n        }\n\n        connectionRef.current = connection;\n\n        // Set up event listeners\n        connection.on(RealtimeEvents.SESSION_STARTED, () => {\n          setStatus(\"connected\");\n          onSessionStarted?.();\n        });\n\n        connection.on(RealtimeEvents.PARTIAL_TRANSCRIPT, (data: unknown) => {\n          const message = data as PartialTranscriptMessage;\n          setPartialTranscript(message.text);\n          setStatus(\"transcribing\");\n          onPartialTranscript?.(message);\n        });\n\n        connection.on(RealtimeEvents.COMMITTED_TRANSCRIPT, (data: unknown) => {\n          const message = data as CommittedTranscriptMessage;\n          const segment: TranscriptSegment = {\n            id: `${Date.now()}-${Math.random()}`,\n            text: message.text,\n            timestamp: Date.now(),\n            isFinal: true,\n          };\n          setCommittedTranscripts(prev => [...prev, segment]);\n          setPartialTranscript(\"\");\n          onCommittedTranscript?.(message);\n        });\n\n        connection.on(\n          RealtimeEvents.COMMITTED_TRANSCRIPT_WITH_TIMESTAMPS,\n          (data: unknown) => {\n            const message = data as CommittedTranscriptWithTimestampsMessage;\n            const segment: TranscriptSegment = {\n              id: `${Date.now()}-${Math.random()}`,\n              text: message.text,\n              timestamp: Date.now(),\n              isFinal: true,\n              words: message.words,\n            };\n            setCommittedTranscripts(prev => [...prev, segment]);\n            setPartialTranscript(\"\");\n            onCommittedTranscriptWithTimestamps?.(message);\n          }\n        );\n\n        connection.on(RealtimeEvents.ERROR, (err: unknown) => {\n          const message = err as ScribeErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onError?.(new Error(message.error));\n        });\n\n        connection.on(RealtimeEvents.AUTH_ERROR, (data: unknown) => {\n          const message = data as ScribeAuthErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onAuthError?.(message);\n        });\n\n        connection.on(RealtimeEvents.QUOTA_EXCEEDED, (data: unknown) => {\n          const message = data as ScribeQuotaExceededErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onQuotaExceededError?.(message);\n        });\n\n        connection.on(RealtimeEvents.COMMIT_THROTTLED, (data: unknown) => {\n          const message = data as ScribeCommitThrottledErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onCommitThrottledError?.(message);\n        });\n\n        connection.on(RealtimeEvents.TRANSCRIBER_ERROR, (data: unknown) => {\n          const message = data as ScribeTranscriberErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onTranscriberError?.(message);\n        });\n\n        connection.on(RealtimeEvents.UNACCEPTED_TERMS, (data: unknown) => {\n          const message = data as ScribeUnacceptedTermsErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onUnacceptedTermsError?.(message);\n        });\n\n        connection.on(RealtimeEvents.RATE_LIMITED, (data: unknown) => {\n          const message = data as ScribeRateLimitedErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onRateLimitedError?.(message);\n        });\n\n        connection.on(RealtimeEvents.INPUT_ERROR, (data: unknown) => {\n          const message = data as ScribeInputErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onInputError?.(message);\n        });\n\n        connection.on(RealtimeEvents.QUEUE_OVERFLOW, (data: unknown) => {\n          const message = data as ScribeQueueOverflowErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onQueueOverflowError?.(message);\n        });\n\n        connection.on(RealtimeEvents.RESOURCE_EXHAUSTED, (data: unknown) => {\n          const message = data as ScribeResourceExhaustedErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onResourceExhaustedError?.(message);\n        });\n\n        connection.on(\n          RealtimeEvents.SESSION_TIME_LIMIT_EXCEEDED,\n          (data: unknown) => {\n            const message = data as ScribeSessionTimeLimitExceededErrorMessage;\n            setError(message.error);\n            setStatus(\"error\");\n            onSessionTimeLimitExceededError?.(message);\n          }\n        );\n\n        connection.on(RealtimeEvents.CHUNK_SIZE_EXCEEDED, (data: unknown) => {\n          const message = data as ScribeChunkSizeExceededErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onChunkSizeExceededError?.(message);\n        });\n\n        connection.on(\n          RealtimeEvents.INSUFFICIENT_AUDIO_ACTIVITY,\n          (data: unknown) => {\n            const message = data as ScribeInsufficientAudioActivityErrorMessage;\n            setError(message.error);\n            setStatus(\"error\");\n            onInsufficientAudioActivityError?.(message);\n          }\n        );\n\n        connection.on(RealtimeEvents.OPEN, () => {\n          onConnect?.();\n        });\n\n        connection.on(RealtimeEvents.CLOSE, () => {\n          setStatus(\"disconnected\");\n          connectionRef.current = null;\n          onDisconnect?.();\n        });\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error ? err.message : \"Failed to connect\";\n        setError(errorMessage);\n        setStatus(\"error\");\n        throw err;\n      }\n    },\n    [\n      defaultToken,\n      defaultModelId,\n      defaultBaseUri,\n      defaultCommitStrategy,\n      defaultVadSilenceThresholdSecs,\n      defaultVadThreshold,\n      defaultMinSpeechDurationMs,\n      defaultMinSilenceDurationMs,\n      defaultLanguageCode,\n      defaultMicrophone,\n      defaultAudioFormat,\n      defaultSampleRate,\n      defaultIncludeTimestamps,\n      onSessionStarted,\n      onPartialTranscript,\n      onCommittedTranscript,\n      onCommittedTranscriptWithTimestamps,\n      onError,\n      onAuthError,\n      onQuotaExceededError,\n      onCommitThrottledError,\n      onTranscriberError,\n      onUnacceptedTermsError,\n      onRateLimitedError,\n      onInputError,\n      onQueueOverflowError,\n      onResourceExhaustedError,\n      onSessionTimeLimitExceededError,\n      onChunkSizeExceededError,\n      onInsufficientAudioActivityError,\n      onConnect,\n      onDisconnect,\n    ]\n  );\n\n  const disconnect = useCallback(() => {\n    connectionRef.current?.close();\n    connectionRef.current = null;\n    setStatus(\"disconnected\");\n  }, []);\n\n  const sendAudio = useCallback(\n    (\n      audioBase64: string,\n      options?: { commit?: boolean; sampleRate?: number; previousText?: string }\n    ) => {\n      if (!connectionRef.current) {\n        throw new Error(\"Not connected to Scribe\");\n      }\n      connectionRef.current.send({ audioBase64, ...options });\n    },\n    []\n  );\n\n  const commit = useCallback(() => {\n    if (!connectionRef.current) {\n      throw new Error(\"Not connected to Scribe\");\n    }\n    connectionRef.current.commit();\n  }, []);\n\n  const clearTranscripts = useCallback(() => {\n    setCommittedTranscripts([]);\n    setPartialTranscript(\"\");\n  }, []);\n\n  const getConnection = useCallback(() => {\n    return connectionRef.current;\n  }, []);\n\n  // Auto-connect if enabled\n  useEffect(() => {\n    if (autoConnect) {\n      connect();\n    }\n  }, [autoConnect, connect]);\n\n  return {\n    // State\n    status,\n    isConnected: status === \"connected\" || status === \"transcribing\",\n    isTranscribing: status === \"transcribing\",\n    partialTranscript,\n    committedTranscripts,\n    error,\n\n    // Methods\n    connect,\n    disconnect,\n    sendAudio,\n    commit,\n    clearTranscripts,\n    getConnection,\n  };\n}\n\n// Export types and enums from client for convenience\nexport {\n  AudioFormat,\n  CommitStrategy,\n  RealtimeEvents,\n} from \"@elevenlabs/client\";\nexport type { RealtimeConnection } from \"@elevenlabs/client\";\n"],"names":["parseLocation","location","console","warn","getOriginForLocation","us","global","getLivekitUrlForLocation","props","micMuted","volume","serverLocation","defaultOptions","_objectWithoutPropertiesLoose","_excluded","conversationRef","useRef","lockRef","shouldEndRef","_useState","useState","status","setStatus","_useState2","canSendFeedback","setCanSendFeedback","_useState3","mode","setMode","micMutedRef","volumeRef","current","useEffect","_conversationRef$curr","undefined","setMicMuted","_conversationRef$curr2","setVolume","_conversationRef$curr3","then","conv","endSession","startSession","options","_conversationRef$curr4","_exit","_temp4","_result","origin","resolvedServerLocation","calculatedLivekitUrl","Conversation","_extends","livekitUrl","overrides","_defaultOptions$overr","_options$overrides","client","_defaultOptions$overr2","_defaultOptions$overr3","_options$overrides$cl","_options$overrides2","source","_options$overrides3","_defaultOptions$overr4","version","_options$overrides4","_defaultOptions$overr5","onConnect","onDisconnect","onError","onMessage","onAudio","onDebug","onUnhandledClientToolCall","onVadScore","onInterruption","onAgentToolRequest","onAgentToolResponse","onConversationMetadata","onMCPToolCall","onMCPConnectionStatus","onAsrInitiationMetadata","onAgentChatResponsePart","onAudioAlignment","onModeChange","_ref","_ref2","onStatusChange","_ref3","_ref4","onCanSendFeedbackChange","_ref5","_ref6","Promise","resolve","_lockRef$current","_temp2","_result3","getId","_temp","Error","_finallyRethrows","_wasThrown","_result2","isOpen","_temp3","conversation","_conversation$getId","e","reject","pendingConnection","_temp5","_ref7","_conversationRef$curr5","getInputByteFrequencyData","_conversationRef$curr6","getOutputByteFrequencyData","_conversationRef$curr7","getInputVolume","_conversationRef$curr8","_conversationRef$curr9","getOutputVolume","_conversationRef$curr0","_conversationRef$curr1","sendFeedback","like","_conversationRef$curr10","_conversationRef$curr11","sendContextualUpdate","text","_conversationRef$curr12","sendUserMessage","_conversationRef$curr13","sendUserActivity","_conversationRef$curr14","sendMCPToolApprovalResult","toolCallId","isApproved","_conversationRef$curr15","changeInputDevice","config","_temp7","_exit3","_result4","_temp6","_await$conversationRe","changeOutputDevice","_exit4","_temp9","_result5","_temp8","_await$conversationRe2","isSpeaking","onSessionStarted","onPartialTranscript","onCommittedTranscript","onCommittedTranscriptWithTimestamps","onAuthError","onQuotaExceededError","onCommitThrottledError","onTranscriberError","onUnacceptedTermsError","onRateLimitedError","onInputError","onQueueOverflowError","onResourceExhaustedError","onSessionTimeLimitExceededError","onChunkSizeExceededError","onInsufficientAudioActivityError","defaultToken","token","defaultModelId","modelId","defaultBaseUri","baseUri","defaultCommitStrategy","commitStrategy","defaultVadSilenceThresholdSecs","vadSilenceThresholdSecs","defaultVadThreshold","vadThreshold","defaultMinSpeechDurationMs","minSpeechDurationMs","defaultMinSilenceDurationMs","minSilenceDurationMs","defaultLanguageCode","languageCode","defaultMicrophone","microphone","defaultAudioFormat","audioFormat","defaultSampleRate","sampleRate","_options$autoConnect","autoConnect","defaultIncludeTimestamps","includeTimestamps","connectionRef","partialTranscript","setPartialTranscript","committedTranscripts","setCommittedTranscripts","_useState4","error","setError","_connectionRef$curren","close","connect","useCallback","runtimeOptions","_runtimeOptions$inclu","connection","Scribe","on","RealtimeEvents","SESSION_STARTED","PARTIAL_TRANSCRIPT","data","message","COMMITTED_TRANSCRIPT","segment","id","Date","now","Math","random","timestamp","isFinal","prev","concat","COMMITTED_TRANSCRIPT_WITH_TIMESTAMPS","words","ERROR","err","AUTH_ERROR","QUOTA_EXCEEDED","COMMIT_THROTTLED","TRANSCRIBER_ERROR","UNACCEPTED_TERMS","RATE_LIMITED","INPUT_ERROR","QUEUE_OVERFLOW","RESOURCE_EXHAUSTED","SESSION_TIME_LIMIT_EXCEEDED","CHUNK_SIZE_EXCEEDED","INSUFFICIENT_AUDIO_ACTIVITY","OPEN","CLOSE","errorMessage","disconnect","_connectionRef$curren2","sendAudio","audioBase64","send","commit","clearTranscripts","getConnection","isConnected","isTranscribing"],"mappings":"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"}