{"version":3,"file":"livekit-client.e2ee.worker.js","sources":["../node_modules/.pnpm/loglevel@1.9.2/node_modules/loglevel/lib/loglevel.js","../src/logger.ts","../src/utils/AsyncQueue.ts","../node_modules/.pnpm/@livekit+mutex@1.1.1/node_modules/@livekit/mutex/dist/index.mjs","../src/e2ee/constants.ts","../src/room/errors.ts","../src/e2ee/errors.ts","../src/e2ee/events.ts","../src/e2ee/utils.ts","../src/e2ee/worker/DataCryptor.ts","../node_modules/.pnpm/events@3.3.0/node_modules/events/events.js","../src/e2ee/worker/naluUtils.ts","../src/e2ee/worker/sifPayload.ts","../src/e2ee/worker/FrameCryptor.ts","../src/e2ee/worker/ParticipantKeyHandler.ts","../src/e2ee/worker/e2ee.worker.ts"],"sourcesContent":["/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    var _loggersByName = {};\n    var defaultLogger = null;\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods() {\n        /*jshint validthis:true */\n        var level = this.getLevel();\n\n        // Replace the actual methods.\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, this.name);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n\n        // Return any important warnings.\n        if (typeof console === undefinedType && level < this.levels.SILENT) {\n            return \"No console available for logging\";\n        }\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, _level, _loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, factory) {\n      // Private instance variables.\n      var self = this;\n      /**\n       * The level inherited from a parent logger (or a global default). We\n       * cache this here rather than delegating to the parent so that it stays\n       * in sync with the actual logging methods that we have installed (the\n       * parent could change levels but we might not have rebuilt the loggers\n       * in this child yet).\n       * @type {number}\n       */\n      var inheritedLevel;\n      /**\n       * The default level for this logger, if any. If set, this overrides\n       * `inheritedLevel`.\n       * @type {number|null}\n       */\n      var defaultLevel;\n      /**\n       * A user-specific level for this logger. If set, this overrides\n       * `defaultLevel`.\n       * @type {number|null}\n       */\n      var userLevel;\n\n      var storageKey = \"loglevel\";\n      if (typeof name === \"string\") {\n        storageKey += \":\" + name;\n      } else if (typeof name === \"symbol\") {\n        storageKey = undefined;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var cookieName = encodeURIComponent(storageKey);\n                  var location = cookie.indexOf(cookieName + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(\n                          cookie.slice(location + cookieName.length + 1)\n                      )[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      function clearPersistedLevel() {\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage.removeItem(storageKey);\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n          } catch (ignore) {}\n      }\n\n      function normalizeLevel(input) {\n          var level = input;\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              return level;\n          } else {\n              throw new TypeError(\"log.setLevel() called with invalid level: \" + input);\n          }\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          if (userLevel != null) {\n            return userLevel;\n          } else if (defaultLevel != null) {\n            return defaultLevel;\n          } else {\n            return inheritedLevel;\n          }\n      };\n\n      self.setLevel = function (level, persist) {\n          userLevel = normalizeLevel(level);\n          if (persist !== false) {  // defaults to true\n              persistLevelIfPossible(userLevel);\n          }\n\n          // NOTE: in v2, this should call rebuild(), which updates children.\n          return replaceLoggingMethods.call(self);\n      };\n\n      self.setDefaultLevel = function (level) {\n          defaultLevel = normalizeLevel(level);\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.resetLevel = function () {\n          userLevel = null;\n          clearPersistedLevel();\n          replaceLoggingMethods.call(self);\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      self.rebuild = function () {\n          if (defaultLogger !== self) {\n              inheritedLevel = normalizeLevel(defaultLogger.getLevel());\n          }\n          replaceLoggingMethods.call(self);\n\n          if (defaultLogger === self) {\n              for (var childName in _loggersByName) {\n                _loggersByName[childName].rebuild();\n              }\n          }\n      };\n\n      // Initialize all the internal levels.\n      inheritedLevel = normalizeLevel(\n          defaultLogger ? defaultLogger.getLevel() : \"WARN\"\n      );\n      var initialLevel = getPersistedLevel();\n      if (initialLevel != null) {\n          userLevel = normalizeLevel(initialLevel);\n      }\n      replaceLoggingMethods.call(self);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    defaultLogger = new Logger();\n\n    defaultLogger.getLogger = function getLogger(name) {\n        if ((typeof name !== \"symbol\" && typeof name !== \"string\") || name === \"\") {\n            throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n            logger = _loggersByName[name] = new Logger(\n                name,\n                defaultLogger.methodFactory\n            );\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    // ES6 default export, for compatibility\n    defaultLogger['default'] = defaultLogger;\n\n    return defaultLogger;\n}));\n","import * as log from 'loglevel';\n\nexport enum LogLevel {\n  trace = 0,\n  debug = 1,\n  info = 2,\n  warn = 3,\n  error = 4,\n  silent = 5,\n}\n\nexport enum LoggerNames {\n  Default = 'livekit',\n  Room = 'livekit-room',\n  TokenSource = 'livekit-token-source',\n  Participant = 'livekit-participant',\n  Track = 'livekit-track',\n  Publication = 'livekit-track-publication',\n  Engine = 'livekit-engine',\n  Signal = 'livekit-signal',\n  PCManager = 'livekit-pc-manager',\n  PCTransport = 'livekit-pc-transport',\n  E2EE = 'lk-e2ee',\n}\n\ntype LogLevelString = keyof typeof LogLevel;\n\nexport type StructuredLogger = log.Logger & {\n  trace: (msg: string, context?: object) => void;\n  debug: (msg: string, context?: object) => void;\n  info: (msg: string, context?: object) => void;\n  warn: (msg: string, context?: object) => void;\n  error: (msg: string, context?: object) => void;\n  setDefaultLevel: (level: log.LogLevelDesc) => void;\n  setLevel: (level: log.LogLevelDesc) => void;\n  getLevel: () => number;\n};\n\nlet livekitLogger = log.getLogger('livekit');\nconst livekitLoggers = Object.values(LoggerNames).map((name) => log.getLogger(name));\n\nlivekitLogger.setDefaultLevel(LogLevel.info);\n\nexport default livekitLogger as StructuredLogger;\n\n/**\n * @internal\n */\nexport function getLogger(name: string) {\n  const logger = log.getLogger(name);\n  logger.setDefaultLevel(livekitLogger.getLevel());\n  return logger as StructuredLogger;\n}\n\nexport function setLogLevel(level: LogLevel | LogLevelString, loggerName?: LoggerNames) {\n  if (loggerName) {\n    log.getLogger(loggerName).setLevel(level);\n  } else {\n    for (const logger of livekitLoggers) {\n      logger.setLevel(level);\n    }\n  }\n}\n\nexport type LogExtension = (level: LogLevel, msg: string, context?: object) => void;\n\n/**\n * use this to hook into the logging function to allow sending internal livekit logs to third party services\n * if set, the browser logs will lose their stacktrace information (see https://github.com/pimterry/loglevel#writing-plugins)\n */\nexport function setLogExtension(extension: LogExtension, logger?: StructuredLogger) {\n  const loggers = logger ? [logger] : livekitLoggers;\n\n  loggers.forEach((logR) => {\n    const originalFactory = logR.methodFactory;\n\n    logR.methodFactory = (methodName, configLevel, loggerName) => {\n      const rawMethod = originalFactory(methodName, configLevel, loggerName);\n\n      const logLevel = LogLevel[methodName as LogLevelString];\n      const needLog = logLevel >= configLevel && logLevel < LogLevel.silent;\n\n      return (msg, context?: [msg: string, context: object]) => {\n        if (context) rawMethod(msg, context);\n        else rawMethod(msg);\n        if (needLog) {\n          extension(logLevel, msg, context);\n        }\n      };\n    };\n    logR.setLevel(logR.getLevel());\n  });\n}\n\nexport const workerLogger = log.getLogger('lk-e2ee') as StructuredLogger;\n","import { Mutex } from '@livekit/mutex';\n\ntype QueueTask<T> = () => PromiseLike<T>;\n\nenum QueueTaskStatus {\n  'WAITING',\n  'RUNNING',\n  'COMPLETED',\n}\n\ntype QueueTaskInfo = {\n  id: number;\n  enqueuedAt: number;\n  executedAt?: number;\n  status: QueueTaskStatus;\n};\n\nexport class AsyncQueue {\n  private pendingTasks: Map<number, QueueTaskInfo>;\n\n  private taskMutex: Mutex;\n\n  private nextTaskIndex: number;\n\n  constructor() {\n    this.pendingTasks = new Map();\n    this.taskMutex = new Mutex();\n    this.nextTaskIndex = 0;\n  }\n\n  async run<T>(task: QueueTask<T>) {\n    const taskInfo: QueueTaskInfo = {\n      id: this.nextTaskIndex++,\n      enqueuedAt: Date.now(),\n      status: QueueTaskStatus.WAITING,\n    };\n    this.pendingTasks.set(taskInfo.id, taskInfo);\n    const unlock = await this.taskMutex.lock();\n    try {\n      taskInfo.executedAt = Date.now();\n      taskInfo.status = QueueTaskStatus.RUNNING;\n      return await task();\n    } finally {\n      taskInfo.status = QueueTaskStatus.COMPLETED;\n      this.pendingTasks.delete(taskInfo.id);\n      unlock();\n    }\n  }\n\n  async flush() {\n    return this.run(async () => {});\n  }\n\n  snapshot() {\n    return Array.from(this.pendingTasks.values());\n  }\n}\n","var e = Object.defineProperty;\nvar h = (i, s, t) => s in i ? e(i, s, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[s] = t;\nvar o = (i, s, t) => h(i, typeof s != \"symbol\" ? s + \"\" : s, t);\nclass _ {\n  constructor() {\n    o(this, \"_locking\");\n    o(this, \"_locks\");\n    this._locking = Promise.resolve(), this._locks = 0;\n  }\n  isLocked() {\n    return this._locks > 0;\n  }\n  lock() {\n    this._locks += 1;\n    let s;\n    const t = new Promise(\n      (l) => s = () => {\n        this._locks -= 1, l();\n      }\n    ), c = this._locking.then(() => s);\n    return this._locking = this._locking.then(() => t), c;\n  }\n}\nclass n {\n  constructor(s) {\n    o(this, \"_queue\");\n    o(this, \"_limit\");\n    o(this, \"_locks\");\n    this._queue = [], this._limit = s, this._locks = 0;\n  }\n  isLocked() {\n    return this._locks >= this._limit;\n  }\n  async lock() {\n    return this.isLocked() ? new Promise((s) => {\n      this._queue.push(() => {\n        this._locks++, s(this._unlock.bind(this));\n      });\n    }) : (this._locks++, this._unlock.bind(this));\n  }\n  _unlock() {\n    if (this._locks--, this._queue.length && !this.isLocked()) {\n      const s = this._queue.shift();\n      s == null || s();\n    }\n  }\n}\nexport {\n  n as MultiMutex,\n  _ as Mutex\n};\n//# sourceMappingURL=index.mjs.map\n","import type { KeyProviderOptions } from './types';\n\nexport const ENCRYPTION_ALGORITHM = 'AES-GCM';\n\n// How many consecutive frames can fail decrypting before a particular key gets marked as invalid\nexport const DECRYPTION_FAILURE_TOLERANCE = 10;\n\n// We copy the first bytes of the VP8 payload unencrypted.\n// For keyframes this is 10 bytes, for non-keyframes (delta) 3. See\n//   https://tools.ietf.org/html/rfc6386#section-9.1\n// This allows the bridge to continue detecting keyframes (only one byte needed in the JVB)\n// and is also a bit easier for the VP8 decoder (i.e. it generates funny garbage pictures\n// instead of being unable to decode).\n// This is a bit for show and we might want to reduce to 1 unconditionally in the final version.\n//\n// For audio (where frame.type is not set) we do not encrypt the opus TOC byte:\n//   https://tools.ietf.org/html/rfc6716#section-3.1\nexport const UNENCRYPTED_BYTES = {\n  key: 10,\n  delta: 3,\n  audio: 1, // frame.type is not set on audio, so this is set manually\n  empty: 0,\n} as const;\n\n/* We use a 12 byte bit IV. This is signalled in plain together with the\n packet. See https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters */\nexport const IV_LENGTH = 12;\n\n// flag set to indicate that e2ee has been setup for sender/receiver;\nexport const E2EE_FLAG = 'lk_e2ee';\n\nexport const SALT = 'LKFrameEncryptionKey';\n\nexport const KEY_PROVIDER_DEFAULTS: KeyProviderOptions = {\n  sharedKey: false,\n  ratchetSalt: SALT,\n  ratchetWindowSize: 8,\n  failureTolerance: DECRYPTION_FAILURE_TOLERANCE,\n  keyringSize: 16,\n} as const;\n\nexport const MAX_SIF_COUNT = 100;\nexport const MAX_SIF_DURATION = 2000;\n","import { DisconnectReason, RequestResponse_Reason } from '@livekit/protocol';\n\n/** Base error that all LiveKit specific custom errors inherit from. */\nexport class LivekitError extends Error {\n  code: number;\n\n  // More info: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/cause\n  cause?: unknown;\n\n  constructor(code: number, message?: string, options?: { cause?: unknown }) {\n    super(message || 'an error has occurred');\n    this.name = 'LiveKitError';\n    this.code = code;\n\n    if (typeof options?.cause !== 'undefined') {\n      this.cause = options?.cause;\n    }\n  }\n}\n\n/**\n * LiveKit specific error type representing an error with an associated set of reasons.\n * Use this to represent an error with multiple different but contextually related variants.\n * */\nexport abstract class LivekitReasonedError<Reason> extends LivekitError {\n  abstract reason: Reason;\n\n  abstract reasonName: string;\n}\n\nexport class SimulatedError extends LivekitError {\n  readonly name = 'simulated';\n\n  constructor(message = 'Simulated failure') {\n    super(-1, message);\n  }\n}\n\nexport enum ConnectionErrorReason {\n  NotAllowed,\n  ServerUnreachable,\n  InternalError,\n  Cancelled,\n  LeaveRequest,\n  Timeout,\n  WebSocket,\n  ServiceNotFound,\n}\n\ntype NotAllowed = {\n  reason: ConnectionErrorReason.NotAllowed;\n  status: number;\n  context?: unknown;\n};\n\ntype InternalError = {\n  reason: ConnectionErrorReason.InternalError;\n  status: never;\n  context?: { status?: number; statusText?: string };\n};\n\ntype ConnectionTimeout = {\n  reason: ConnectionErrorReason.Timeout;\n  status: never;\n  context: never;\n};\n\ntype LeaveRequest = {\n  reason: ConnectionErrorReason.LeaveRequest;\n  status: never;\n  context: DisconnectReason;\n};\n\ntype Cancelled = {\n  reason: ConnectionErrorReason.Cancelled;\n  status: never;\n  context: never;\n};\n\ntype ServerUnreachable = {\n  reason: ConnectionErrorReason.ServerUnreachable;\n  status?: number;\n  context?: never;\n};\n\ntype WebSocket = {\n  reason: ConnectionErrorReason.WebSocket;\n  status?: number;\n  context?: string;\n};\n\ntype ServiceNotFound = {\n  reason: ConnectionErrorReason.ServiceNotFound;\n  status: never;\n  context: string;\n};\n\ntype ConnectionErrorVariants =\n  | NotAllowed\n  | ConnectionTimeout\n  | LeaveRequest\n  | InternalError\n  | Cancelled\n  | ServerUnreachable\n  | WebSocket\n  | ServiceNotFound;\n\nexport class ConnectionError<\n  Variant extends ConnectionErrorVariants = ConnectionErrorVariants,\n> extends LivekitReasonedError<Variant['reason']> {\n  status?: Variant['status'];\n\n  context: Variant['context'];\n\n  reason: Variant['reason'];\n\n  reasonName: string;\n\n  readonly name = 'ConnectionError';\n\n  protected constructor(\n    message: string,\n    reason: Variant['reason'],\n    status?: Variant['status'],\n    context?: Variant['context'],\n  ) {\n    super(1, message);\n    this.status = status;\n    this.reason = reason;\n    this.context = context;\n    this.reasonName = ConnectionErrorReason[reason];\n  }\n\n  static notAllowed(message: string, status: number, context?: unknown) {\n    return new ConnectionError<NotAllowed>(\n      message,\n      ConnectionErrorReason.NotAllowed,\n      status,\n      context,\n    );\n  }\n\n  static timeout(message: string) {\n    return new ConnectionError<ConnectionTimeout>(message, ConnectionErrorReason.Timeout);\n  }\n\n  static leaveRequest(message: string, context: DisconnectReason) {\n    return new ConnectionError<LeaveRequest>(\n      message,\n      ConnectionErrorReason.LeaveRequest,\n      undefined,\n      context,\n    );\n  }\n\n  static internal(message: string, context?: { status?: number; statusText?: string }) {\n    return new ConnectionError<InternalError>(\n      message,\n      ConnectionErrorReason.InternalError,\n      undefined,\n      context,\n    );\n  }\n\n  static cancelled(message: string) {\n    return new ConnectionError<Cancelled>(message, ConnectionErrorReason.Cancelled);\n  }\n\n  static serverUnreachable(message: string, status?: number) {\n    return new ConnectionError<ServerUnreachable>(\n      message,\n      ConnectionErrorReason.ServerUnreachable,\n      status,\n    );\n  }\n\n  static websocket(message: string, status?: number, reason?: string) {\n    return new ConnectionError<WebSocket>(message, ConnectionErrorReason.WebSocket, status, reason);\n  }\n\n  static serviceNotFound(message: string, serviceName: 'v0-rtc') {\n    return new ConnectionError<ServiceNotFound>(\n      message,\n      ConnectionErrorReason.ServiceNotFound,\n      undefined,\n      serviceName,\n    );\n  }\n}\n\nexport class DeviceUnsupportedError extends LivekitError {\n  readonly name = 'DeviceUnsupportedError';\n\n  constructor(message?: string) {\n    super(21, message ?? 'device is unsupported');\n  }\n}\n\nexport class TrackInvalidError extends LivekitError {\n  readonly name = 'TrackInvalidError';\n\n  constructor(message?: string) {\n    super(20, message ?? 'track is invalid');\n  }\n}\n\nexport class UnsupportedServer extends LivekitError {\n  readonly name = 'UnsupportedServer';\n\n  constructor(message?: string) {\n    super(10, message ?? 'unsupported server');\n  }\n}\n\nexport class UnexpectedConnectionState extends LivekitError {\n  readonly name = 'UnexpectedConnectionState';\n\n  constructor(message?: string) {\n    super(12, message ?? 'unexpected connection state');\n  }\n}\n\nexport class NegotiationError extends LivekitError {\n  readonly name = 'NegotiationError';\n\n  constructor(message?: string) {\n    super(13, message ?? 'unable to negotiate');\n  }\n}\n\nexport class PublishDataError extends LivekitError {\n  readonly name = 'PublishDataError';\n\n  constructor(message?: string) {\n    super(14, message ?? 'unable to publish data');\n  }\n}\n\nexport class PublishTrackError extends LivekitError {\n  readonly name = 'PublishTrackError';\n\n  status: number;\n\n  constructor(message: string, status: number) {\n    super(15, message);\n    this.status = status;\n  }\n}\n\nexport type RequestErrorReason =\n  | Exclude<RequestResponse_Reason, RequestResponse_Reason.OK>\n  | 'TimeoutError';\n\nexport class SignalRequestError extends LivekitReasonedError<RequestErrorReason> {\n  readonly name = 'SignalRequestError';\n\n  reason: RequestErrorReason;\n\n  reasonName: string;\n\n  constructor(message: string, reason: RequestErrorReason) {\n    super(15, message);\n    this.reason = reason;\n    this.reasonName = typeof reason === 'string' ? reason : RequestResponse_Reason[reason];\n  }\n}\n\n// NOTE: matches with https://github.com/livekit/client-sdk-swift/blob/f37bbd260d61e165084962db822c79f995f1a113/Sources/LiveKit/DataStream/StreamError.swift#L17\nexport enum DataStreamErrorReason {\n  // Unable to open a stream with the same ID more than once.\n  AlreadyOpened = 0,\n\n  // Stream closed abnormally by remote participant.\n  AbnormalEnd = 1,\n\n  // Incoming chunk data could not be decoded.\n  DecodeFailed = 2,\n\n  // Read length exceeded total length specified in stream header.\n  LengthExceeded = 3,\n\n  // Read length less than total length specified in stream header.\n  Incomplete = 4,\n\n  // Unable to register a stream handler more than once.\n  HandlerAlreadyRegistered = 7,\n\n  // Encryption type mismatch.\n  EncryptionTypeMismatch = 8,\n}\n\nexport class DataStreamError extends LivekitReasonedError<DataStreamErrorReason> {\n  readonly name = 'DataStreamError';\n\n  reason: DataStreamErrorReason;\n\n  reasonName: string;\n\n  constructor(message: string, reason: DataStreamErrorReason) {\n    super(16, message);\n    this.reason = reason;\n    this.reasonName = DataStreamErrorReason[reason];\n  }\n}\n\nexport class SignalReconnectError extends LivekitError {\n  readonly name = 'SignalReconnectError';\n\n  constructor(message?: string) {\n    super(18, message);\n  }\n}\n\nexport enum MediaDeviceFailure {\n  // user rejected permissions\n  PermissionDenied = 'PermissionDenied',\n  // device is not available\n  NotFound = 'NotFound',\n  // device is in use. On Windows, only a single tab may get access to a device at a time.\n  DeviceInUse = 'DeviceInUse',\n  Other = 'Other',\n}\n\nexport namespace MediaDeviceFailure {\n  export function getFailure(error: any): MediaDeviceFailure | undefined {\n    if (error && 'name' in error) {\n      if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n        return MediaDeviceFailure.NotFound;\n      }\n      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n        return MediaDeviceFailure.PermissionDenied;\n      }\n      if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {\n        return MediaDeviceFailure.DeviceInUse;\n      }\n      return MediaDeviceFailure.Other;\n    }\n  }\n}\n","import { LivekitError } from '../room/errors';\n\nexport enum CryptorErrorReason {\n  InvalidKey = 0,\n  MissingKey = 1,\n  InternalError = 2,\n}\n\nexport class CryptorError extends LivekitError {\n  reason: CryptorErrorReason;\n\n  participantIdentity?: string;\n\n  constructor(\n    message?: string,\n    reason: CryptorErrorReason = CryptorErrorReason.InternalError,\n    participantIdentity?: string,\n  ) {\n    super(40, message);\n    this.reason = reason;\n    this.participantIdentity = participantIdentity;\n  }\n}\n","import type Participant from '../room/participant/Participant';\nimport type { CryptorError } from './errors';\nimport type { KeyInfo, RatchetResult } from './types';\n\nexport enum KeyProviderEvent {\n  SetKey = 'setKey',\n  /** Event for requesting to ratchet the key used to encrypt the stream */\n  RatchetRequest = 'ratchetRequest',\n  /** Emitted when a key is ratcheted. Could be after auto-ratcheting on decryption failure or\n   *  following a `RatchetRequest`, will contain the ratcheted key material */\n  KeyRatcheted = 'keyRatcheted',\n}\n\nexport type KeyProviderCallbacks = {\n  [KeyProviderEvent.SetKey]: (keyInfo: KeyInfo) => void;\n  [KeyProviderEvent.RatchetRequest]: (participantIdentity?: string, keyIndex?: number) => void;\n  [KeyProviderEvent.KeyRatcheted]: (\n    ratchetedResult: RatchetResult,\n    participantIdentity?: string,\n    keyIndex?: number,\n  ) => void;\n};\n\nexport enum KeyHandlerEvent {\n  /** Emitted when a key has been ratcheted. Is emitted when any key has been ratcheted\n   * i.e. when the FrameCryptor tried to ratchet when decryption is failing  */\n  KeyRatcheted = 'keyRatcheted',\n}\n\nexport type ParticipantKeyHandlerCallbacks = {\n  [KeyHandlerEvent.KeyRatcheted]: (\n    ratchetResult: RatchetResult,\n    participantIdentity: string,\n    keyIndex?: number,\n  ) => void;\n};\n\nexport enum EncryptionEvent {\n  ParticipantEncryptionStatusChanged = 'participantEncryptionStatusChanged',\n  EncryptionError = 'encryptionError',\n}\n\nexport type E2EEManagerCallbacks = {\n  [EncryptionEvent.ParticipantEncryptionStatusChanged]: (\n    enabled: boolean,\n    participant: Participant,\n  ) => void;\n  [EncryptionEvent.EncryptionError]: (error: Error, participantIdentity?: string) => void;\n};\n\nexport type CryptorCallbacks = {\n  [CryptorEvent.Error]: (error: CryptorError) => void;\n};\n\nexport enum CryptorEvent {\n  Error = 'cryptorError',\n}\n","import { type DataPacket, EncryptedPacketPayload } from '@livekit/protocol';\nimport { ENCRYPTION_ALGORITHM } from './constants';\n\nexport function isE2EESupported() {\n  return isInsertableStreamSupported() || isScriptTransformSupported();\n}\n\nexport function isScriptTransformSupported() {\n  // @ts-ignore\n  return typeof window.RTCRtpScriptTransform !== 'undefined';\n}\n\nexport function isInsertableStreamSupported() {\n  return (\n    typeof window.RTCRtpSender !== 'undefined' &&\n    // @ts-ignore\n    typeof window.RTCRtpSender.prototype.createEncodedStreams !== 'undefined'\n  );\n}\n\nexport function isVideoFrame(\n  frame: RTCEncodedAudioFrame | RTCEncodedVideoFrame,\n): frame is RTCEncodedVideoFrame {\n  return 'type' in frame;\n}\n\nexport async function importKey(\n  keyBytes: Uint8Array | ArrayBuffer,\n  algorithm: string | { name: string } = { name: ENCRYPTION_ALGORITHM },\n  usage: 'derive' | 'encrypt' = 'encrypt',\n) {\n  // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey\n  return crypto.subtle.importKey(\n    'raw',\n    keyBytes,\n    algorithm,\n    false,\n    usage === 'derive' ? ['deriveBits', 'deriveKey'] : ['encrypt', 'decrypt'],\n  );\n}\n\nexport async function createKeyMaterialFromString(password: string) {\n  let enc = new TextEncoder();\n\n  const keyMaterial = await crypto.subtle.importKey(\n    'raw',\n    enc.encode(password),\n    {\n      name: 'PBKDF2',\n    },\n    false,\n    ['deriveBits', 'deriveKey'],\n  );\n\n  return keyMaterial;\n}\n\nexport async function createKeyMaterialFromBuffer(cryptoBuffer: ArrayBuffer) {\n  const keyMaterial = await crypto.subtle.importKey('raw', cryptoBuffer, 'HKDF', false, [\n    'deriveBits',\n    'deriveKey',\n  ]);\n\n  return keyMaterial;\n}\n\nfunction getAlgoOptions(algorithmName: string, salt: string) {\n  const textEncoder = new TextEncoder();\n  const encodedSalt = textEncoder.encode(salt);\n  switch (algorithmName) {\n    case 'HKDF':\n      return {\n        name: 'HKDF',\n        salt: encodedSalt,\n        hash: 'SHA-256',\n        info: new ArrayBuffer(128),\n      };\n    case 'PBKDF2': {\n      return {\n        name: 'PBKDF2',\n        salt: encodedSalt,\n        hash: 'SHA-256',\n        iterations: 100000,\n      };\n    }\n    default:\n      throw new Error(`algorithm ${algorithmName} is currently unsupported`);\n  }\n}\n\n/**\n * Derives a set of keys from the master key.\n * See https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.1\n */\nexport async function deriveKeys(material: CryptoKey, salt: string) {\n  const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey#HKDF\n  // https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams\n  const encryptionKey = await crypto.subtle.deriveKey(\n    algorithmOptions,\n    material,\n    {\n      name: ENCRYPTION_ALGORITHM,\n      length: 128,\n    },\n    false,\n    ['encrypt', 'decrypt'],\n  );\n\n  return { material, encryptionKey };\n}\n\nexport function createE2EEKey(): Uint8Array {\n  return window.crypto.getRandomValues(new Uint8Array(32));\n}\n\n/**\n * Ratchets a key. See\n * https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.5.1\n */\nexport async function ratchet(material: CryptoKey, salt: string): Promise<ArrayBuffer> {\n  const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveBits\n  return crypto.subtle.deriveBits(algorithmOptions, material, 256);\n}\n\nexport function needsRbspUnescaping(frameData: Uint8Array) {\n  for (var i = 0; i < frameData.length - 3; i++) {\n    if (frameData[i] == 0 && frameData[i + 1] == 0 && frameData[i + 2] == 3) return true;\n  }\n  return false;\n}\n\nexport function parseRbsp(stream: Uint8Array): Uint8Array {\n  const dataOut: number[] = [];\n  var length = stream.length;\n  for (var i = 0; i < stream.length; ) {\n    // Be careful about over/underflow here. byte_length_ - 3 can underflow, and\n    // i + 3 can overflow, but byte_length_ - i can't, because i < byte_length_\n    // above, and that expression will produce the number of bytes left in\n    // the stream including the byte at i.\n    if (length - i >= 3 && !stream[i] && !stream[i + 1] && stream[i + 2] == 3) {\n      // Two rbsp bytes.\n      dataOut.push(stream[i++]);\n      dataOut.push(stream[i++]);\n      // Skip the emulation byte.\n      i++;\n    } else {\n      // Single rbsp byte.\n      dataOut.push(stream[i++]);\n    }\n  }\n  return new Uint8Array(dataOut);\n}\n\nconst kZerosInStartSequence = 2;\nconst kEmulationByte = 3;\n\nexport function writeRbsp(data_in: Uint8Array): Uint8Array {\n  const dataOut: number[] = [];\n  var numConsecutiveZeros = 0;\n  for (var i = 0; i < data_in.length; ++i) {\n    var byte = data_in[i];\n    if (byte <= kEmulationByte && numConsecutiveZeros >= kZerosInStartSequence) {\n      // Need to escape.\n      dataOut.push(kEmulationByte);\n      numConsecutiveZeros = 0;\n    }\n    dataOut.push(byte);\n    if (byte == 0) {\n      ++numConsecutiveZeros;\n    } else {\n      numConsecutiveZeros = 0;\n    }\n  }\n  return new Uint8Array(dataOut);\n}\n\nexport function asEncryptablePacket(packet: DataPacket): EncryptedPacketPayload | undefined {\n  if (\n    packet.value?.case !== 'sipDtmf' &&\n    packet.value?.case !== 'metrics' &&\n    packet.value?.case !== 'speaker' &&\n    packet.value?.case !== 'transcription' &&\n    packet.value?.case !== 'encryptedPacket'\n  ) {\n    return new EncryptedPacketPayload({\n      value: packet.value,\n    });\n  }\n  return undefined;\n}\n","import { workerLogger } from '../../logger';\nimport { ENCRYPTION_ALGORITHM } from '../constants';\nimport { CryptorError, CryptorErrorReason } from '../errors';\nimport type { DecodeRatchetOptions, KeySet, RatchetResult } from '../types';\nimport { deriveKeys } from '../utils';\nimport type { ParticipantKeyHandler } from './ParticipantKeyHandler';\n\nexport class DataCryptor {\n  private static sendCount = 0;\n\n  private static makeIV(timestamp: number) {\n    const iv = new ArrayBuffer(12);\n    const ivView = new DataView(iv);\n    const randomBytes = crypto.getRandomValues(new Uint32Array(1));\n    ivView.setUint32(0, randomBytes[0]);\n    ivView.setUint32(4, timestamp);\n    ivView.setUint32(8, timestamp - (DataCryptor.sendCount % 0xffff));\n    DataCryptor.sendCount++;\n\n    return iv;\n  }\n\n  static async encrypt(\n    data: Uint8Array,\n    keys: ParticipantKeyHandler,\n  ): Promise<{\n    payload: Uint8Array;\n    iv: Uint8Array;\n    keyIndex: number;\n  }> {\n    const iv = DataCryptor.makeIV(performance.now());\n    const keySet = await keys.getKeySet();\n    if (!keySet) {\n      throw new Error('No key set found');\n    }\n\n    const cipherText = await crypto.subtle.encrypt(\n      {\n        name: ENCRYPTION_ALGORITHM,\n        iv,\n      },\n      keySet.encryptionKey,\n      new Uint8Array(data),\n    );\n\n    return {\n      payload: new Uint8Array(cipherText),\n      iv: new Uint8Array(iv),\n      keyIndex: keys.getCurrentKeyIndex(),\n    };\n  }\n\n  static async decrypt(\n    data: Uint8Array,\n    iv: Uint8Array,\n    keys: ParticipantKeyHandler,\n    keyIndex: number = 0,\n    initialMaterial?: KeySet,\n    ratchetOpts: DecodeRatchetOptions = { ratchetCount: 0 },\n  ): Promise<{\n    payload: Uint8Array;\n  }> {\n    const keySet = await keys.getKeySet(keyIndex);\n    if (!keySet) {\n      throw new Error('No key set found');\n    }\n\n    try {\n      const plainText = await crypto.subtle.decrypt(\n        {\n          name: ENCRYPTION_ALGORITHM,\n          iv,\n        },\n        keySet.encryptionKey,\n        new Uint8Array(data),\n      );\n      return {\n        payload: new Uint8Array(plainText),\n      };\n    } catch (error: any) {\n      if (keys.keyProviderOptions.ratchetWindowSize > 0) {\n        if (ratchetOpts.ratchetCount < keys.keyProviderOptions.ratchetWindowSize) {\n          workerLogger.debug(\n            `DataCryptor: ratcheting key attempt ${ratchetOpts.ratchetCount} of ${\n              keys.keyProviderOptions.ratchetWindowSize\n            }, for data packet`,\n          );\n\n          let ratchetedKeySet: KeySet | undefined;\n          let ratchetResult: RatchetResult | undefined;\n          if ((initialMaterial ?? keySet) === keys.getKeySet(keyIndex)) {\n            // only ratchet if the currently set key is still the same as the one used to decrypt this frame\n            // if not, it might be that a different frame has already ratcheted and we try with that one first\n            ratchetResult = await keys.ratchetKey(keyIndex, false);\n\n            ratchetedKeySet = await deriveKeys(\n              ratchetResult.cryptoKey,\n              keys.keyProviderOptions.ratchetSalt,\n            );\n          }\n\n          const decryptedData = await DataCryptor.decrypt(\n            data,\n            iv,\n            keys,\n            keyIndex,\n            initialMaterial,\n            {\n              ratchetCount: ratchetOpts.ratchetCount + 1,\n              encryptionKey: ratchetedKeySet?.encryptionKey,\n            },\n          );\n\n          if (decryptedData && ratchetedKeySet) {\n            // before updating the keys, make sure that the keySet used for this frame is still the same as the currently set key\n            // if it's not, a new key might have been set already, which we don't want to override\n            if ((initialMaterial ?? keySet) === keys.getKeySet(keyIndex)) {\n              keys.setKeySet(ratchetedKeySet, keyIndex, ratchetResult);\n              // decryption was successful, set the new key index to reflect the ratcheted key set\n              keys.setCurrentKeyIndex(keyIndex);\n            }\n          }\n          return decryptedData;\n        } else {\n          /**\n           * Because we only set a new key once decryption has been successful,\n           * we can be sure that we don't need to reset the key to the initial material at this point\n           * as the key has not been updated on the keyHandler instance\n           */\n\n          workerLogger.warn('DataCryptor: maximum ratchet attempts exceeded');\n          throw new CryptorError(\n            `DataCryptor: valid key missing for participant ${keys.participantIdentity}`,\n            CryptorErrorReason.InvalidKey,\n            keys.participantIdentity,\n          );\n        }\n      } else {\n        throw new CryptorError(\n          `DataCryptor: Decryption failed: ${error.message}`,\n          CryptorErrorReason.InvalidKey,\n          keys.participantIdentity,\n        );\n      }\n    }\n  }\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","/**\n * NALU (Network Abstraction Layer Unit) utilities for H.264 and H.265 video processing\n * Contains functions for parsing and working with NALUs in video frames\n */\n\n/**\n * Mask for extracting NALU type from H.264 header byte\n */\nconst kH264NaluTypeMask = 0x1f;\n\n/**\n * H.264 NALU types according to RFC 6184\n */\nenum H264NALUType {\n  /** Coded slice of a non-IDR picture */\n  SLICE_NON_IDR = 1,\n  /** Coded slice data partition A */\n  SLICE_PARTITION_A = 2,\n  /** Coded slice data partition B */\n  SLICE_PARTITION_B = 3,\n  /** Coded slice data partition C */\n  SLICE_PARTITION_C = 4,\n  /** Coded slice of an IDR picture */\n  SLICE_IDR = 5,\n  /** Supplemental enhancement information */\n  SEI = 6,\n  /** Sequence parameter set */\n  SPS = 7,\n  /** Picture parameter set */\n  PPS = 8,\n  /** Access unit delimiter */\n  AUD = 9,\n  /** End of sequence */\n  END_SEQ = 10,\n  /** End of stream */\n  END_STREAM = 11,\n  /** Filler data */\n  FILLER_DATA = 12,\n  /** Sequence parameter set extension */\n  SPS_EXT = 13,\n  /** Prefix NAL unit */\n  PREFIX_NALU = 14,\n  /** Subset sequence parameter set */\n  SUBSET_SPS = 15,\n  /** Depth parameter set */\n  DPS = 16,\n\n  // 17, 18 reserved\n\n  /** Coded slice of an auxiliary coded picture without partitioning */\n  SLICE_AUX = 19,\n  /** Coded slice extension */\n  SLICE_EXT = 20,\n  /** Coded slice extension for a depth view component or a 3D-AVC texture view component */\n  SLICE_LAYER_EXT = 21,\n\n  // 22, 23 reserved\n}\n\n/**\n * H.265/HEVC NALU types according to ITU-T H.265\n */\nenum H265NALUType {\n  /** Coded slice segment of a non-TSA, non-STSA trailing picture */\n  TRAIL_N = 0,\n  /** Coded slice segment of a non-TSA, non-STSA trailing picture */\n  TRAIL_R = 1,\n  /** Coded slice segment of a TSA picture */\n  TSA_N = 2,\n  /** Coded slice segment of a TSA picture */\n  TSA_R = 3,\n  /** Coded slice segment of an STSA picture */\n  STSA_N = 4,\n  /** Coded slice segment of an STSA picture */\n  STSA_R = 5,\n  /** Coded slice segment of a RADL picture */\n  RADL_N = 6,\n  /** Coded slice segment of a RADL picture */\n  RADL_R = 7,\n  /** Coded slice segment of a RASL picture */\n  RASL_N = 8,\n  /** Coded slice segment of a RASL picture */\n  RASL_R = 9,\n\n  // 10-15 reserved\n\n  /** Coded slice segment of a BLA picture */\n  BLA_W_LP = 16,\n  /** Coded slice segment of a BLA picture */\n  BLA_W_RADL = 17,\n  /** Coded slice segment of a BLA picture */\n  BLA_N_LP = 18,\n  /** Coded slice segment of an IDR picture */\n  IDR_W_RADL = 19,\n  /** Coded slice segment of an IDR picture */\n  IDR_N_LP = 20,\n  /** Coded slice segment of a CRA picture */\n  CRA_NUT = 21,\n\n  // 22-31 reserved\n\n  /** Video parameter set */\n  VPS_NUT = 32,\n  /** Sequence parameter set */\n  SPS_NUT = 33,\n  /** Picture parameter set */\n  PPS_NUT = 34,\n  /** Access unit delimiter */\n  AUD_NUT = 35,\n  /** End of sequence */\n  EOS_NUT = 36,\n  /** End of bitstream */\n  EOB_NUT = 37,\n  /** Filler data */\n  FD_NUT = 38,\n  /** Supplemental enhancement information */\n  PREFIX_SEI_NUT = 39,\n  /** Supplemental enhancement information */\n  SUFFIX_SEI_NUT = 40,\n\n  // 41-47 reserved\n  // 48-63 unspecified\n}\n\n/**\n * Parse H.264 NALU type from the first byte of a NALU\n * @param startByte First byte of the NALU\n * @returns H.264 NALU type\n */\nfunction parseH264NALUType(startByte: number): H264NALUType {\n  return startByte & kH264NaluTypeMask;\n}\n\n/**\n * Parse H.265 NALU type from the first byte of a NALU\n * @param firstByte First byte of the NALU\n * @returns H.265 NALU type\n */\nfunction parseH265NALUType(firstByte: number): H265NALUType {\n  // In H.265, NALU type is in bits 1-6 (shifted right by 1)\n  return (firstByte >> 1) & 0x3f;\n}\n\n/**\n * Check if H.264 NALU type is a slice (IDR or non-IDR)\n * @param naluType H.264 NALU type\n * @returns True if the NALU is a slice\n */\nfunction isH264SliceNALU(naluType: H264NALUType): boolean {\n  return naluType === H264NALUType.SLICE_IDR || naluType === H264NALUType.SLICE_NON_IDR;\n}\n\n/**\n * Check if H.265 NALU type is a slice\n * @param naluType H.265 NALU type\n * @returns True if the NALU is a slice\n */\nfunction isH265SliceNALU(naluType: H265NALUType): boolean {\n  return (\n    // VCL NALUs (Video Coding Layer) - slice segments\n    naluType === H265NALUType.TRAIL_N ||\n    naluType === H265NALUType.TRAIL_R ||\n    naluType === H265NALUType.TSA_N ||\n    naluType === H265NALUType.TSA_R ||\n    naluType === H265NALUType.STSA_N ||\n    naluType === H265NALUType.STSA_R ||\n    naluType === H265NALUType.RADL_N ||\n    naluType === H265NALUType.RADL_R ||\n    naluType === H265NALUType.RASL_N ||\n    naluType === H265NALUType.RASL_R ||\n    naluType === H265NALUType.BLA_W_LP ||\n    naluType === H265NALUType.BLA_W_RADL ||\n    naluType === H265NALUType.BLA_N_LP ||\n    naluType === H265NALUType.IDR_W_RADL ||\n    naluType === H265NALUType.IDR_N_LP ||\n    naluType === H265NALUType.CRA_NUT\n  );\n}\n\n/**\n * Detected codec type from NALU analysis\n */\nexport type DetectedCodec = 'h264' | 'h265' | 'unknown';\n\n/**\n * Result of NALU processing for frame encryption\n */\nexport interface NALUProcessingResult {\n  /** Number of unencrypted bytes at the start of the frame */\n  unencryptedBytes: number;\n  /** Detected codec type */\n  detectedCodec: DetectedCodec;\n  /** Whether this frame requires NALU processing */\n  requiresNALUProcessing: boolean;\n}\n\n/**\n * Detect codec type by examining NALU types in the data\n * @param data Frame data\n * @param naluIndices Indices where NALUs start\n * @returns Detected codec type\n */\nfunction detectCodecFromNALUs(data: Uint8Array, naluIndices: number[]): DetectedCodec {\n  for (const naluIndex of naluIndices) {\n    if (isH264SliceNALU(parseH264NALUType(data[naluIndex]))) return 'h264';\n    if (isH265SliceNALU(parseH265NALUType(data[naluIndex]))) return 'h265';\n  }\n  return 'unknown';\n}\n\n/**\n * Find the first slice NALU and return the number of unencrypted bytes\n * @param data Frame data\n * @param naluIndices Indices where NALUs start\n * @param codec Codec type to use for parsing\n * @returns Number of unencrypted bytes (index + 2) or null if no slice found\n */\nfunction findSliceNALUUnencryptedBytes(\n  data: Uint8Array,\n  naluIndices: number[],\n  codec: 'h264' | 'h265',\n): number | null {\n  for (const index of naluIndices) {\n    if (codec === 'h265') {\n      const type = parseH265NALUType(data[index]);\n      if (isH265SliceNALU(type)) {\n        return index + 2;\n      }\n    } else {\n      const type = parseH264NALUType(data[index]);\n      if (isH264SliceNALU(type)) {\n        return index + 2;\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Find all NALU start indices in a byte stream\n * Supports both H.264 and H.265 with 3-byte and 4-byte start codes\n *\n * This function slices the NALUs present in the supplied buffer, assuming it is already byte-aligned.\n * Code adapted from https://github.com/medooze/h264-frame-parser/blob/main/lib/NalUnits.ts to return indices only\n *\n * @param stream Byte stream containing NALUs\n * @returns Array of indices where NALUs start (after the start code)\n */\nfunction findNALUIndices(stream: Uint8Array): number[] {\n  const result: number[] = [];\n  let start = 0,\n    pos = 0,\n    searchLength = stream.length - 3; // Changed to -3 to handle 4-byte start codes\n\n  while (pos < searchLength) {\n    // skip until end of current NALU - check for both 3-byte and 4-byte start codes\n    while (pos < searchLength) {\n      // Check for 4-byte start code: 0x00 0x00 0x00 0x01\n      if (\n        pos < searchLength - 1 &&\n        stream[pos] === 0 &&\n        stream[pos + 1] === 0 &&\n        stream[pos + 2] === 0 &&\n        stream[pos + 3] === 1\n      ) {\n        break;\n      }\n      // Check for 3-byte start code: 0x00 0x00 0x01\n      if (stream[pos] === 0 && stream[pos + 1] === 0 && stream[pos + 2] === 1) {\n        break;\n      }\n      pos++;\n    }\n\n    if (pos >= searchLength) pos = stream.length;\n\n    // remove trailing zeros from current NALU\n    let end = pos;\n    while (end > start && stream[end - 1] === 0) end--;\n\n    // save current NALU\n    if (start === 0) {\n      if (end !== start) throw TypeError('byte stream contains leading data');\n    } else {\n      result.push(start);\n    }\n\n    // begin new NALU - determine start code length\n    let startCodeLength = 3;\n    if (\n      pos < stream.length - 3 &&\n      stream[pos] === 0 &&\n      stream[pos + 1] === 0 &&\n      stream[pos + 2] === 0 &&\n      stream[pos + 3] === 1\n    ) {\n      startCodeLength = 4;\n    }\n\n    start = pos = pos + startCodeLength;\n  }\n  return result;\n}\n\n/**\n * Process NALU data for frame encryption, detecting codec and finding unencrypted bytes\n * @param data Frame data\n * @param knownCodec Known codec from other sources (optional)\n * @returns NALU processing result\n */\nexport function processNALUsForEncryption(\n  data: Uint8Array,\n  knownCodec?: 'h264' | 'h265',\n): NALUProcessingResult {\n  const naluIndices = findNALUIndices(data);\n  const detectedCodec = knownCodec ?? detectCodecFromNALUs(data, naluIndices);\n\n  if (detectedCodec === 'unknown') {\n    return { unencryptedBytes: 0, detectedCodec, requiresNALUProcessing: false };\n  }\n\n  const unencryptedBytes = findSliceNALUUnencryptedBytes(data, naluIndices, detectedCodec);\n  if (unencryptedBytes === null) {\n    throw new TypeError('Could not find NALU');\n  }\n\n  return { unencryptedBytes, detectedCodec, requiresNALUProcessing: true };\n}\n","import type { VideoCodec } from '../..';\n\n//  Payload definitions taken from https://github.com/livekit/livekit/blob/master/pkg/sfu/downtrack.go#L104\n\nexport const VP8KeyFrame8x8: Uint8Array = new Uint8Array([\n  0x10, 0x02, 0x00, 0x9d, 0x01, 0x2a, 0x08, 0x00, 0x08, 0x00, 0x00, 0x47, 0x08, 0x85, 0x85, 0x88,\n  0x85, 0x84, 0x88, 0x02, 0x02, 0x00, 0x0c, 0x0d, 0x60, 0x00, 0xfe, 0xff, 0xab, 0x50, 0x80,\n]);\n\nexport const H264KeyFrame2x2SPS: Uint8Array = new Uint8Array([\n  0x67, 0x42, 0xc0, 0x1f, 0x0f, 0xd9, 0x1f, 0x88, 0x88, 0x84, 0x00, 0x00, 0x03, 0x00, 0x04, 0x00,\n  0x00, 0x03, 0x00, 0xc8, 0x3c, 0x60, 0xc9, 0x20,\n]);\n\nexport const H264KeyFrame2x2PPS: Uint8Array = new Uint8Array([0x68, 0x87, 0xcb, 0x83, 0xcb, 0x20]);\n\nexport const H264KeyFrame2x2IDR: Uint8Array = new Uint8Array([\n  0x65, 0x88, 0x84, 0x0a, 0xf2, 0x62, 0x80, 0x00, 0xa7, 0xbe,\n]);\n\nexport const H264KeyFrame2x2: Uint8Array[] = [\n  H264KeyFrame2x2SPS,\n  H264KeyFrame2x2PPS,\n  H264KeyFrame2x2IDR,\n];\n\nexport const OpusSilenceFrame: Uint8Array = new Uint8Array([\n  0xf8, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n]);\n\n/**\n * Create a crypto hash using Web Crypto API for secure comparison operations\n */\nasync function cryptoHash(data: Uint8Array | ArrayBuffer): Promise<string> {\n  const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n  const hashArray = new Uint8Array(hashBuffer);\n  return Array.from(hashArray)\n    .map((b) => b.toString(16).padStart(2, '0'))\n    .join('');\n}\n\n/**\n * Pre-computed SHA-256 hashes for secure comparison operations\n */\nexport const CryptoHashes = {\n  VP8KeyFrame8x8: 'ef0161653d8b2b23aad46624b420af1d03ce48950e9fc85718028f91b50f9219',\n  H264KeyFrame2x2SPS: 'f0a0e09647d891d6d50aa898bce7108090375d0d55e50a2bb21147afee558e44',\n  H264KeyFrame2x2PPS: '61d9665eed71b6d424ae9539330a3bdd5cb386d4d781c808219a6e36750493a7',\n  H264KeyFrame2x2IDR: 'faffc26b68a2fc09096fa20f3351e706398b6f838a7500c8063472c2e476e90d',\n  OpusSilenceFrame: 'aad8d31fc56b2802ca500e58c2fb9d0b29ad71bb7cb52cd6530251eade188988',\n} as const;\n\n/**\n * Check if a byte array matches any of the known SIF payload frame types using secure crypto hashes\n */\nexport async function identifySifPayload(\n  data: Uint8Array | ArrayBuffer,\n): Promise<VideoCodec | 'opus' | null> {\n  const hash = await cryptoHash(data);\n\n  switch (hash) {\n    case CryptoHashes.VP8KeyFrame8x8:\n      return 'vp8';\n    case CryptoHashes.H264KeyFrame2x2SPS:\n      return 'h264';\n    case CryptoHashes.H264KeyFrame2x2PPS:\n      return 'h264';\n    case CryptoHashes.H264KeyFrame2x2IDR:\n      return 'h264';\n    case CryptoHashes.OpusSilenceFrame:\n      return 'opus';\n    default:\n      return null;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-unused-vars */\n// TODO code inspired by https://github.com/webrtc/samples/blob/gh-pages/src/content/insertable-streams/endtoend-encryption/js/worker.js\nimport { EventEmitter } from 'events';\nimport type TypedEventEmitter from 'typed-emitter';\nimport { workerLogger } from '../../logger';\nimport type { VideoCodec } from '../../room/track/options';\nimport { ENCRYPTION_ALGORITHM, IV_LENGTH, UNENCRYPTED_BYTES } from '../constants';\nimport { CryptorError, CryptorErrorReason } from '../errors';\nimport { type CryptorCallbacks, CryptorEvent } from '../events';\nimport type { DecodeRatchetOptions, KeyProviderOptions, KeySet, RatchetResult } from '../types';\nimport { deriveKeys, isVideoFrame, needsRbspUnescaping, parseRbsp, writeRbsp } from '../utils';\nimport type { ParticipantKeyHandler } from './ParticipantKeyHandler';\nimport { processNALUsForEncryption } from './naluUtils';\nimport { identifySifPayload } from './sifPayload';\n\nexport const encryptionEnabledMap: Map<string, boolean> = new Map();\n\nexport interface FrameCryptorConstructor {\n  new (opts?: unknown): BaseFrameCryptor;\n}\n\nexport interface TransformerInfo {\n  readable: ReadableStream;\n  writable: WritableStream;\n  transformer: TransformStream;\n  trackId: string;\n  symbol: symbol;\n}\n\nexport class BaseFrameCryptor extends (EventEmitter as new () => TypedEventEmitter<CryptorCallbacks>) {\n  protected encodeFunction(\n    encodedFrame: RTCEncodedVideoFrame | RTCEncodedAudioFrame,\n    controller: TransformStreamDefaultController,\n  ): Promise<any> {\n    throw Error('not implemented for subclass');\n  }\n\n  protected decodeFunction(\n    encodedFrame: RTCEncodedVideoFrame | RTCEncodedAudioFrame,\n    controller: TransformStreamDefaultController,\n  ): Promise<any> {\n    throw Error('not implemented for subclass');\n  }\n}\n\n/**\n * Cryptor is responsible for en-/decrypting media frames.\n * Each Cryptor instance is responsible for en-/decrypting a single mediaStreamTrack.\n */\nexport class FrameCryptor extends BaseFrameCryptor {\n  private sendCounts: Map<number, number>;\n\n  private participantIdentity: string | undefined;\n\n  private trackId: string | undefined;\n\n  private keys: ParticipantKeyHandler;\n\n  private videoCodec?: VideoCodec;\n\n  private rtpMap: Map<number, VideoCodec>;\n\n  private keyProviderOptions: KeyProviderOptions;\n\n  /**\n   * used for detecting server injected unencrypted frames\n   */\n  private sifTrailer: Uint8Array;\n\n  private detectedCodec?: VideoCodec;\n\n  private currentTransform?: TransformerInfo;\n\n  /**\n   * Throttling mechanism for decryption errors to prevent memory leaks\n   */\n  private lastErrorTimestamp: Map<string, number> = new Map();\n\n  private errorCounts: Map<string, number> = new Map();\n\n  private readonly ERROR_THROTTLE_MS = 1000; // Emit error at most once per second\n\n  private readonly MAX_ERRORS_PER_MINUTE = 5; // Maximum errors to emit per minute per key\n\n  private readonly ERROR_WINDOW_MS = 60000; // 1 minute window\n\n  constructor(opts: {\n    keys: ParticipantKeyHandler;\n    participantIdentity: string;\n    keyProviderOptions: KeyProviderOptions;\n    sifTrailer?: Uint8Array;\n  }) {\n    super();\n    this.sendCounts = new Map();\n    this.keys = opts.keys;\n    this.participantIdentity = opts.participantIdentity;\n    this.rtpMap = new Map();\n    this.keyProviderOptions = opts.keyProviderOptions;\n    this.sifTrailer = opts.sifTrailer ?? Uint8Array.from([]);\n  }\n\n  private get logContext() {\n    return {\n      participant: this.participantIdentity,\n      mediaTrackId: this.trackId,\n      fallbackCodec: this.videoCodec,\n    };\n  }\n\n  /**\n   * Assign a different participant to the cryptor.\n   * useful for transceiver re-use\n   * @param id\n   * @param keys\n   */\n  setParticipant(id: string, keys: ParticipantKeyHandler) {\n    workerLogger.debug('setting new participant on cryptor', {\n      ...this.logContext,\n      newParticipant: id,\n      hadPreviousParticipant: !!this.participantIdentity,\n    });\n\n    if (this.participantIdentity && this.participantIdentity !== id) {\n      workerLogger.warn('cryptor has already a participant set, cleaning up before switching', {\n        oldParticipant: this.participantIdentity,\n        newParticipant: id,\n        trackId: this.trackId,\n      });\n      // Clean up state from previous participant\n      this.unsetParticipant();\n    }\n\n    this.participantIdentity = id;\n    this.keys = keys;\n  }\n\n  unsetParticipant() {\n    workerLogger.debug('unsetting participant', this.logContext);\n\n    if (this.currentTransform) {\n      this.currentTransform = undefined;\n    }\n\n    this.participantIdentity = undefined;\n    this.lastErrorTimestamp = new Map();\n    this.errorCounts = new Map();\n  }\n\n  isEnabled() {\n    if (this.participantIdentity) {\n      return encryptionEnabledMap.get(this.participantIdentity);\n    } else {\n      return undefined;\n    }\n  }\n\n  getParticipantIdentity() {\n    return this.participantIdentity;\n  }\n\n  getTrackId() {\n    return this.trackId;\n  }\n\n  /**\n   * Update the video codec used by the mediaStreamTrack\n   * @param codec\n   */\n  setVideoCodec(codec: VideoCodec) {\n    this.videoCodec = codec;\n  }\n\n  /**\n   * rtp payload type map used for figuring out codec of payload type when encoding\n   * @param map\n   */\n  setRtpMap(map: Map<number, VideoCodec>) {\n    this.rtpMap = map;\n  }\n\n  setupTransform(\n    operation: 'encode' | 'decode',\n    readable: ReadableStream<RTCEncodedVideoFrame | RTCEncodedAudioFrame>,\n    writable: WritableStream<RTCEncodedVideoFrame | RTCEncodedAudioFrame>,\n    trackId: string,\n    isReuse: boolean,\n    codec?: VideoCodec,\n  ) {\n    if (codec) {\n      workerLogger.info('setting codec on cryptor to', { codec });\n      this.videoCodec = codec;\n    }\n\n    workerLogger.debug('Setting up frame cryptor transform', {\n      operation,\n      passedTrackId: trackId,\n      codec,\n      isReuse,\n      hasCurrentTransform: !!this.currentTransform,\n      ...this.logContext,\n    });\n\n    // Always update trackId, even on reuse\n    this.trackId = trackId;\n\n    // If we're reusing and have an active transform skip setup\n    if (\n      isReuse &&\n      this.currentTransform &&\n      readable === this.currentTransform.readable &&\n      writable === this.currentTransform.writable\n    ) {\n      workerLogger.debug('reusing existing transform', {\n        ...this.logContext,\n        trackId,\n      });\n      return;\n    }\n\n    const symbol = Symbol('transform');\n\n    const transformFn = operation === 'encode' ? this.encodeFunction : this.decodeFunction;\n    const transformStream = new TransformStream({\n      transform: transformFn.bind(this),\n    });\n\n    // Store transform info before starting the pipe\n    this.currentTransform = {\n      readable,\n      writable,\n      transformer: transformStream,\n      trackId,\n      symbol,\n    };\n\n    readable\n      .pipeThrough(transformStream)\n      .pipeTo(writable)\n      .catch((e) => {\n        if (e instanceof TypeError && e.message === 'Destination stream closed') {\n          // this can happen when subscriptions happen in quick successions, but doesn't influence functionality\n          workerLogger.debug('destination stream closed');\n        } else {\n          workerLogger.warn('transform error', { error: e, ...this.logContext });\n          this.emit(\n            CryptorEvent.Error,\n            e instanceof CryptorError\n              ? e\n              : new CryptorError(e.message, undefined, this.participantIdentity),\n          );\n        }\n      })\n      .finally(() => {\n        // Only clear currentTransform if it's still the same one we started\n        if (this.currentTransform?.symbol === symbol) {\n          workerLogger.debug('transform completed', {\n            ...this.logContext,\n            trackId,\n          });\n          this.currentTransform = undefined;\n        }\n      });\n  }\n\n  setSifTrailer(trailer: Uint8Array) {\n    workerLogger.debug('setting SIF trailer', { ...this.logContext, trailer });\n    this.sifTrailer = trailer;\n  }\n\n  /**\n   * Checks if we should emit an error based on throttling rules to prevent memory leaks\n   * @param errorKey - unique key identifying the error context\n   * @returns true if the error should be emitted, false otherwise\n   */\n  private shouldEmitError(errorKey: string): boolean {\n    const now = Date.now();\n    const lastErrorTime = this.lastErrorTimestamp.get(errorKey) ?? 0;\n    const errorCount = this.errorCounts.get(errorKey) ?? 0;\n\n    // Reset count if we're in a new time window\n    if (now - lastErrorTime > this.ERROR_WINDOW_MS) {\n      this.errorCounts.set(errorKey, 0);\n      this.lastErrorTimestamp.set(errorKey, now);\n      return true;\n    }\n\n    // Check if we've exceeded the throttle time\n    if (now - lastErrorTime < this.ERROR_THROTTLE_MS) {\n      return false;\n    }\n\n    // Check if we've exceeded the max errors per window\n    if (errorCount >= this.MAX_ERRORS_PER_MINUTE) {\n      // Only log a warning once when hitting the limit\n      if (errorCount === this.MAX_ERRORS_PER_MINUTE) {\n        workerLogger.warn(`Suppressing further decryption errors for ${this.participantIdentity}`, {\n          ...this.logContext,\n          errorKey,\n        });\n        this.errorCounts.set(errorKey, errorCount + 1);\n      }\n      return false;\n    }\n\n    // Update tracking\n    this.lastErrorTimestamp.set(errorKey, now);\n    this.errorCounts.set(errorKey, errorCount + 1);\n    return true;\n  }\n\n  /**\n   * Emits a throttled error to prevent memory leaks from repeated decryption failures\n   * @param error - the CryptorError to emit\n   */\n  private emitThrottledError(error: CryptorError) {\n    const errorKey = `${this.participantIdentity}-${error.reason}-decrypt`;\n\n    if (this.shouldEmitError(errorKey)) {\n      const errorCount = this.errorCounts.get(errorKey) ?? 0;\n      if (errorCount > 1) {\n        workerLogger.debug(`Decryption error (${errorCount} occurrences in window)`, {\n          ...this.logContext,\n          reason: CryptorErrorReason[error.reason],\n        });\n      }\n      this.emit(CryptorEvent.Error, error);\n    }\n  }\n\n  /**\n   * Function that will be injected in a stream and will encrypt the given encoded frames.\n   *\n   * @param {RTCEncodedVideoFrame|RTCEncodedAudioFrame} encodedFrame - Encoded video frame.\n   * @param {TransformStreamDefaultController} controller - TransportStreamController.\n   *\n   * The VP8 payload descriptor described in\n   * https://tools.ietf.org/html/rfc7741#section-4.2\n   * is part of the RTP packet and not part of the frame and is not controllable by us.\n   * This is fine as the SFU keeps having access to it for routing.\n   *\n   * The encrypted frame is formed as follows:\n   * 1) Find unencrypted byte length, depending on the codec, frame type and kind.\n   * 2) Form the GCM IV for the frame as described above.\n   * 3) Encrypt the rest of the frame using AES-GCM.\n   * 4) Allocate space for the encrypted frame.\n   * 5) Copy the unencrypted bytes to the start of the encrypted frame.\n   * 6) Append the ciphertext to the encrypted frame.\n   * 7) Append the IV.\n   * 8) Append a single byte for the key identifier.\n   * 9) Enqueue the encrypted frame for sending.\n   */\n  protected async encodeFunction(\n    encodedFrame: RTCEncodedVideoFrame | RTCEncodedAudioFrame,\n    controller: TransformStreamDefaultController,\n  ) {\n    if (\n      !this.isEnabled() ||\n      // skip for encryption for empty dtx frames\n      encodedFrame.data.byteLength === 0\n    ) {\n      return controller.enqueue(encodedFrame);\n    }\n    const keySet = this.keys.getKeySet();\n    if (!keySet) {\n      this.emitThrottledError(\n        new CryptorError(\n          `key set not found for ${\n            this.participantIdentity\n          } at index ${this.keys.getCurrentKeyIndex()}`,\n          CryptorErrorReason.MissingKey,\n          this.participantIdentity,\n        ),\n      );\n      return;\n    }\n    const { encryptionKey } = keySet;\n    const keyIndex = this.keys.getCurrentKeyIndex();\n\n    if (encryptionKey) {\n      const iv = this.makeIV(\n        encodedFrame.getMetadata().synchronizationSource ?? -1,\n        encodedFrame.timestamp,\n      );\n      let frameInfo = this.getUnencryptedBytes(encodedFrame);\n\n      // Ths is not encrypted and contains the VP8 payload descriptor or the Opus TOC byte.\n      const frameHeader = new Uint8Array(encodedFrame.data, 0, frameInfo.unencryptedBytes);\n\n      // Frame trailer contains the R|IV_LENGTH and key index\n      const frameTrailer = new Uint8Array(2);\n\n      frameTrailer[0] = IV_LENGTH;\n      frameTrailer[1] = keyIndex;\n\n      // Construct frame trailer. Similar to the frame header described in\n      // https://tools.ietf.org/html/draft-omara-sframe-00#section-4.2\n      // but we put it at the end.\n      //\n      // ---------+-------------------------+-+---------+----\n      // payload  |IV...(length = IV_LENGTH)|R|IV_LENGTH|KID |\n      // ---------+-------------------------+-+---------+----\n      try {\n        const cipherText = await crypto.subtle.encrypt(\n          {\n            name: ENCRYPTION_ALGORITHM,\n            iv,\n            additionalData: new Uint8Array(encodedFrame.data, 0, frameHeader.byteLength),\n          },\n          encryptionKey,\n          new Uint8Array(encodedFrame.data, frameInfo.unencryptedBytes),\n        );\n\n        let newDataWithoutHeader = new Uint8Array(\n          cipherText.byteLength + iv.byteLength + frameTrailer.byteLength,\n        );\n        newDataWithoutHeader.set(new Uint8Array(cipherText)); // add ciphertext.\n        newDataWithoutHeader.set(new Uint8Array(iv), cipherText.byteLength); // append IV.\n        newDataWithoutHeader.set(frameTrailer, cipherText.byteLength + iv.byteLength); // append frame trailer.\n\n        if (frameInfo.requiresNALUProcessing) {\n          newDataWithoutHeader = writeRbsp(newDataWithoutHeader);\n        }\n\n        var newData = new Uint8Array(frameHeader.byteLength + newDataWithoutHeader.byteLength);\n        newData.set(frameHeader);\n        newData.set(newDataWithoutHeader, frameHeader.byteLength);\n\n        encodedFrame.data = newData.buffer;\n\n        return controller.enqueue(encodedFrame);\n      } catch (e: any) {\n        // TODO: surface this to the app.\n        workerLogger.error(e);\n      }\n    } else {\n      workerLogger.debug('failed to encrypt, emitting error', this.logContext);\n      this.emitThrottledError(\n        new CryptorError(\n          `encryption key missing for encoding`,\n          CryptorErrorReason.MissingKey,\n          this.participantIdentity,\n        ),\n      );\n    }\n  }\n\n  /**\n   * Function that will be injected in a stream and will decrypt the given encoded frames.\n   *\n   * @param {RTCEncodedVideoFrame|RTCEncodedAudioFrame} encodedFrame - Encoded video frame.\n   * @param {TransformStreamDefaultController} controller - TransportStreamController.\n   */\n  protected async decodeFunction(\n    encodedFrame: RTCEncodedVideoFrame | RTCEncodedAudioFrame,\n    controller: TransformStreamDefaultController,\n  ) {\n    if (\n      !this.isEnabled() ||\n      // skip for decryption for empty dtx frames\n      encodedFrame.data.byteLength === 0\n    ) {\n      return controller.enqueue(encodedFrame);\n    }\n\n    if (isFrameServerInjected(encodedFrame.data, this.sifTrailer)) {\n      encodedFrame.data = encodedFrame.data.slice(\n        0,\n        encodedFrame.data.byteLength - this.sifTrailer.byteLength,\n      );\n      if (await identifySifPayload(encodedFrame.data)) {\n        workerLogger.debug('enqueue SIF', this.logContext);\n        return controller.enqueue(encodedFrame);\n      } else {\n        workerLogger.warn('Unexpected SIF frame payload, dropping frame', this.logContext);\n        return;\n      }\n    }\n    const data = new Uint8Array(encodedFrame.data);\n    const keyIndex = data[encodedFrame.data.byteLength - 1];\n\n    if (this.keys.hasInvalidKeyAtIndex(keyIndex)) {\n      // drop frame\n      return;\n    }\n\n    if (this.keys.getKeySet(keyIndex)) {\n      try {\n        const decodedFrame = await this.decryptFrame(encodedFrame, keyIndex);\n        this.keys.decryptionSuccess(keyIndex);\n        if (decodedFrame) {\n          return controller.enqueue(decodedFrame);\n        }\n      } catch (error) {\n        if (error instanceof CryptorError && error.reason === CryptorErrorReason.InvalidKey) {\n          // emit an error if the key handler thinks we have a valid key\n          if (this.keys.hasValidKey) {\n            this.emitThrottledError(error);\n            this.keys.decryptionFailure(keyIndex);\n          }\n        } else {\n          workerLogger.warn('decoding frame failed', { error });\n        }\n      }\n    } else {\n      // emit an error if the key index is out of bounds but the key handler thinks we still have a valid key\n      workerLogger.warn(`skipping decryption due to missing key at index ${keyIndex}`);\n      this.emitThrottledError(\n        new CryptorError(\n          `missing key at index ${keyIndex} for participant ${this.participantIdentity}`,\n          CryptorErrorReason.MissingKey,\n          this.participantIdentity,\n        ),\n      );\n      this.keys.decryptionFailure(keyIndex);\n    }\n  }\n\n  /**\n   * Function that will decrypt the given encoded frame. If the decryption fails, it will\n   * ratchet the key for up to RATCHET_WINDOW_SIZE times.\n   */\n  private async decryptFrame(\n    encodedFrame: RTCEncodedVideoFrame | RTCEncodedAudioFrame,\n    keyIndex: number,\n    initialMaterial: KeySet | undefined = undefined,\n    ratchetOpts: DecodeRatchetOptions = { ratchetCount: 0 },\n  ): Promise<RTCEncodedVideoFrame | RTCEncodedAudioFrame | undefined> {\n    const keySet = this.keys.getKeySet(keyIndex);\n    if (!ratchetOpts.encryptionKey && !keySet) {\n      throw new TypeError(`no encryption key found for decryption of ${this.participantIdentity}`);\n    }\n    let frameInfo = this.getUnencryptedBytes(encodedFrame);\n\n    // Construct frame trailer. Similar to the frame header described in\n    // https://tools.ietf.org/html/draft-omara-sframe-00#section-4.2\n    // but we put it at the end.\n    //\n    // ---------+-------------------------+-+---------+----\n    // payload  |IV...(length = IV_LENGTH)|R|IV_LENGTH|KID |\n    // ---------+-------------------------+-+---------+----\n\n    try {\n      const frameHeader = new Uint8Array(encodedFrame.data, 0, frameInfo.unencryptedBytes);\n      var encryptedData = new Uint8Array(\n        encodedFrame.data,\n        frameHeader.length,\n        encodedFrame.data.byteLength - frameHeader.length,\n      );\n      if (frameInfo.requiresNALUProcessing && needsRbspUnescaping(encryptedData)) {\n        encryptedData = parseRbsp(encryptedData);\n        const newUint8 = new Uint8Array(frameHeader.byteLength + encryptedData.byteLength);\n        newUint8.set(frameHeader);\n        newUint8.set(encryptedData, frameHeader.byteLength);\n        encodedFrame.data = newUint8.buffer;\n      }\n\n      const frameTrailer = new Uint8Array(encodedFrame.data, encodedFrame.data.byteLength - 2, 2);\n\n      const ivLength = frameTrailer[0];\n      const iv = new Uint8Array(\n        encodedFrame.data,\n        encodedFrame.data.byteLength - ivLength - frameTrailer.byteLength,\n        ivLength,\n      );\n\n      const cipherTextStart = frameHeader.byteLength;\n      const cipherTextLength =\n        encodedFrame.data.byteLength -\n        (frameHeader.byteLength + ivLength + frameTrailer.byteLength);\n\n      const plainText = await crypto.subtle.decrypt(\n        {\n          name: ENCRYPTION_ALGORITHM,\n          iv,\n          additionalData: new Uint8Array(encodedFrame.data, 0, frameHeader.byteLength),\n        },\n        ratchetOpts.encryptionKey ?? keySet!.encryptionKey,\n        new Uint8Array(encodedFrame.data, cipherTextStart, cipherTextLength),\n      );\n\n      const newData = new ArrayBuffer(frameHeader.byteLength + plainText.byteLength);\n      const newUint8 = new Uint8Array(newData);\n\n      newUint8.set(new Uint8Array(encodedFrame.data, 0, frameHeader.byteLength));\n      newUint8.set(new Uint8Array(plainText), frameHeader.byteLength);\n\n      encodedFrame.data = newData;\n\n      return encodedFrame;\n    } catch (error: any) {\n      if (this.keyProviderOptions.ratchetWindowSize > 0) {\n        if (ratchetOpts.ratchetCount < this.keyProviderOptions.ratchetWindowSize) {\n          workerLogger.debug(\n            `ratcheting key attempt ${ratchetOpts.ratchetCount} of ${\n              this.keyProviderOptions.ratchetWindowSize\n            }, for kind ${encodedFrame instanceof RTCEncodedAudioFrame ? 'audio' : 'video'}`,\n          );\n\n          let ratchetedKeySet: KeySet | undefined;\n          let ratchetResult: RatchetResult | undefined;\n          if ((initialMaterial ?? keySet) === this.keys.getKeySet(keyIndex)) {\n            // only ratchet if the currently set key is still the same as the one used to decrypt this frame\n            // if not, it might be that a different frame has already ratcheted and we try with that one first\n            ratchetResult = await this.keys.ratchetKey(keyIndex, false);\n\n            ratchetedKeySet = await deriveKeys(\n              ratchetResult.cryptoKey,\n              this.keyProviderOptions.ratchetSalt,\n            );\n          }\n\n          const frame = await this.decryptFrame(encodedFrame, keyIndex, initialMaterial || keySet, {\n            ratchetCount: ratchetOpts.ratchetCount + 1,\n            encryptionKey: ratchetedKeySet?.encryptionKey,\n          });\n          if (frame && ratchetedKeySet) {\n            // before updating the keys, make sure that the keySet used for this frame is still the same as the currently set key\n            // if it's not, a new key might have been set already, which we don't want to override\n            if ((initialMaterial ?? keySet) === this.keys.getKeySet(keyIndex)) {\n              this.keys.setKeySet(ratchetedKeySet, keyIndex, ratchetResult);\n              // decryption was successful, set the new key index to reflect the ratcheted key set\n              this.keys.setCurrentKeyIndex(keyIndex);\n            }\n          }\n          return frame;\n        } else {\n          /**\n           * Because we only set a new key once decryption has been successful,\n           * we can be sure that we don't need to reset the key to the initial material at this point\n           * as the key has not been updated on the keyHandler instance\n           */\n\n          workerLogger.warn('maximum ratchet attempts exceeded');\n          throw new CryptorError(\n            `valid key missing for participant ${this.participantIdentity}`,\n            CryptorErrorReason.InvalidKey,\n            this.participantIdentity,\n          );\n        }\n      } else {\n        throw new CryptorError(\n          `Decryption failed: ${error.message}`,\n          CryptorErrorReason.InvalidKey,\n          this.participantIdentity,\n        );\n      }\n    }\n  }\n\n  /**\n   * Construct the IV used for AES-GCM and sent (in plain) with the packet similar to\n   * https://tools.ietf.org/html/rfc7714#section-8.1\n   * It concatenates\n   * - the 32 bit synchronization source (SSRC) given on the encoded frame,\n   * - the 32 bit rtp timestamp given on the encoded frame,\n   * - a send counter that is specific to the SSRC. Starts at a random number.\n   * The send counter is essentially the pictureId but we currently have to implement this ourselves.\n   * There is no XOR with a salt. Note that this IV leaks the SSRC to the receiver but since this is\n   * randomly generated and SFUs may not rewrite this is considered acceptable.\n   * The SSRC is used to allow demultiplexing multiple streams with the same key, as described in\n   *   https://tools.ietf.org/html/rfc3711#section-4.1.1\n   * The RTP timestamp is 32 bits and advances by the codec clock rate (90khz for video, 48khz for\n   * opus audio) every second. For video it rolls over roughly every 13 hours.\n   * The send counter will advance at the frame rate (30fps for video, 50fps for 20ms opus audio)\n   * every second. It will take a long time to roll over.\n   *\n   * See also https://developer.mozilla.org/en-US/docs/Web/API/AesGcmParams\n   */\n  private makeIV(synchronizationSource: number, timestamp: number) {\n    const iv = new ArrayBuffer(IV_LENGTH);\n    const ivView = new DataView(iv);\n\n    // having to keep our own send count (similar to a picture id) is not ideal.\n    if (!this.sendCounts.has(synchronizationSource)) {\n      // Initialize with a random offset, similar to the RTP sequence number.\n      this.sendCounts.set(synchronizationSource, Math.floor(Math.random() * 0xffff));\n    }\n\n    const sendCount = this.sendCounts.get(synchronizationSource) ?? 0;\n\n    ivView.setUint32(0, synchronizationSource);\n    ivView.setUint32(4, timestamp);\n    ivView.setUint32(8, timestamp - (sendCount % 0xffff));\n\n    this.sendCounts.set(synchronizationSource, sendCount + 1);\n\n    return iv;\n  }\n\n  private getUnencryptedBytes(frame: RTCEncodedVideoFrame | RTCEncodedAudioFrame): {\n    unencryptedBytes: number;\n    requiresNALUProcessing: boolean;\n  } {\n    // Handle audio frames\n    if (!isVideoFrame(frame)) {\n      return { unencryptedBytes: UNENCRYPTED_BYTES.audio, requiresNALUProcessing: false };\n    }\n\n    // Detect and track codec changes\n    const detectedCodec = this.getVideoCodec(frame) ?? this.videoCodec;\n    if (detectedCodec !== this.detectedCodec) {\n      workerLogger.debug('detected different codec', {\n        detectedCodec,\n        oldCodec: this.detectedCodec,\n        ...this.logContext,\n      });\n      this.detectedCodec = detectedCodec;\n    }\n\n    // Check for unsupported codecs\n    if (detectedCodec === 'av1') {\n      throw new Error(`${detectedCodec} is not yet supported for end to end encryption`);\n    }\n\n    // Handle VP8/VP9 codecs (no NALU processing needed)\n    if (detectedCodec === 'vp8') {\n      return { unencryptedBytes: UNENCRYPTED_BYTES[frame.type], requiresNALUProcessing: false };\n    }\n    if (detectedCodec === 'vp9') {\n      return { unencryptedBytes: 0, requiresNALUProcessing: false };\n    }\n\n    // Try NALU processing for H.264/H.265 codecs\n    try {\n      const knownCodec =\n        detectedCodec === 'h264' || detectedCodec === 'h265' ? detectedCodec : undefined;\n      const naluResult = processNALUsForEncryption(new Uint8Array(frame.data), knownCodec);\n\n      if (naluResult.requiresNALUProcessing) {\n        return {\n          unencryptedBytes: naluResult.unencryptedBytes,\n          requiresNALUProcessing: true,\n        };\n      }\n    } catch (e) {\n      workerLogger.debug('NALU processing failed, falling back to VP8 handling', {\n        error: e,\n        ...this.logContext,\n      });\n    }\n\n    // Fallback to VP8 handling\n    return { unencryptedBytes: UNENCRYPTED_BYTES[frame.type], requiresNALUProcessing: false };\n  }\n\n  /**\n   * inspects frame payloadtype if available and maps it to the codec specified in rtpMap\n   */\n  private getVideoCodec(frame: RTCEncodedVideoFrame): VideoCodec | undefined {\n    if (this.rtpMap.size === 0) {\n      return undefined;\n    }\n    const payloadType = frame.getMetadata().payloadType;\n    const codec = payloadType ? this.rtpMap.get(payloadType) : undefined;\n    return codec;\n  }\n}\n\n/**\n * we use a magic frame trailer to detect whether a frame is injected\n * by the livekit server and thus to be treated as unencrypted\n * @internal\n */\nexport function isFrameServerInjected(frameData: ArrayBuffer, trailerBytes: Uint8Array): boolean {\n  if (trailerBytes.byteLength === 0) {\n    return false;\n  }\n  const frameTrailer = new Uint8Array(\n    frameData.slice(frameData.byteLength - trailerBytes.byteLength),\n  );\n  return trailerBytes.every((value, index) => value === frameTrailer[index]);\n}\n","import { EventEmitter } from 'events';\nimport type TypedEventEmitter from 'typed-emitter';\nimport { workerLogger } from '../../logger';\nimport { KeyHandlerEvent, type ParticipantKeyHandlerCallbacks } from '../events';\nimport type { KeyProviderOptions, KeySet, RatchetResult } from '../types';\nimport { deriveKeys, importKey, ratchet } from '../utils';\n\n// TODO ParticipantKeyHandlers currently don't get destroyed on participant disconnect\n// we could do this by having a separate worker message on participant disconnected.\n\n/**\n * ParticipantKeyHandler is responsible for providing a cryptor instance with the\n * en-/decryption key of a participant. It assumes that all tracks of a specific participant\n * are encrypted with the same key.\n * Additionally it exposes a method to ratchet a key which can be used by the cryptor either automatically\n * if decryption fails or can be triggered manually on both sender and receiver side.\n *\n */\nexport class ParticipantKeyHandler extends (EventEmitter as new () => TypedEventEmitter<ParticipantKeyHandlerCallbacks>) {\n  private currentKeyIndex: number;\n\n  private cryptoKeyRing: Array<KeySet | undefined>;\n\n  private decryptionFailureCounts: Array<number>;\n\n  private ratchetPromiseMap: Map<number, Promise<RatchetResult>>;\n\n  readonly participantIdentity: string;\n\n  /** @internal */\n  readonly keyProviderOptions: KeyProviderOptions;\n\n  /**\n   * true if the current key has not been marked as invalid\n   */\n  get hasValidKey(): boolean {\n    return !this.hasInvalidKeyAtIndex(this.currentKeyIndex);\n  }\n\n  constructor(participantIdentity: string, keyProviderOptions: KeyProviderOptions) {\n    super();\n    this.currentKeyIndex = 0;\n    if (keyProviderOptions.keyringSize < 1 || keyProviderOptions.keyringSize > 256) {\n      throw new TypeError('Keyring size needs to be between 1 and 256');\n    }\n    this.cryptoKeyRing = new Array(keyProviderOptions.keyringSize).fill(undefined);\n    this.decryptionFailureCounts = new Array(keyProviderOptions.keyringSize).fill(0);\n    this.keyProviderOptions = keyProviderOptions;\n    this.ratchetPromiseMap = new Map();\n    this.participantIdentity = participantIdentity;\n  }\n\n  /**\n   * Returns true if the key at the given index is marked as invalid.\n   *\n   * @param keyIndex the index of the key\n   */\n  hasInvalidKeyAtIndex(keyIndex: number): boolean {\n    return (\n      this.keyProviderOptions.failureTolerance >= 0 &&\n      this.decryptionFailureCounts[keyIndex] > this.keyProviderOptions.failureTolerance\n    );\n  }\n\n  /**\n   * Informs the key handler that a decryption failure occurred for an encryption key.\n   * @internal\n   * @param keyIndex the key index for which the failure occurred. Defaults to the current key index.\n   */\n  decryptionFailure(keyIndex: number = this.currentKeyIndex): void {\n    if (this.keyProviderOptions.failureTolerance < 0) {\n      return;\n    }\n\n    this.decryptionFailureCounts[keyIndex] += 1;\n\n    if (this.decryptionFailureCounts[keyIndex] > this.keyProviderOptions.failureTolerance) {\n      workerLogger.warn(\n        `key for ${this.participantIdentity} at index ${keyIndex} is being marked as invalid`,\n      );\n    }\n  }\n\n  /**\n   * Informs the key handler that a frame was successfully decrypted using an encryption key.\n   * @internal\n   * @param keyIndex the key index for which the success occurred. Defaults to the current key index.\n   */\n  decryptionSuccess(keyIndex: number = this.currentKeyIndex): void {\n    this.resetKeyStatus(keyIndex);\n  }\n\n  /**\n   * Call this after user initiated ratchet or a new key has been set in order to make sure to mark potentially\n   * invalid keys as valid again\n   *\n   * @param keyIndex the index of the key. Defaults to the current key index.\n   */\n  resetKeyStatus(keyIndex?: number): void {\n    if (keyIndex === undefined) {\n      this.decryptionFailureCounts.fill(0);\n    } else {\n      this.decryptionFailureCounts[keyIndex] = 0;\n    }\n  }\n\n  /**\n   * Ratchets the current key (or the one at keyIndex if provided) and\n   * returns the ratcheted material\n   * if `setKey` is true (default), it will also set the ratcheted key directly on the crypto key ring\n   * @param keyIndex\n   * @param setKey\n   */\n  ratchetKey(keyIndex?: number, setKey = true): Promise<RatchetResult> {\n    const currentKeyIndex = keyIndex ?? this.getCurrentKeyIndex();\n\n    const existingPromise = this.ratchetPromiseMap.get(currentKeyIndex);\n    if (typeof existingPromise !== 'undefined') {\n      return existingPromise;\n    }\n    const ratchetPromise = new Promise<RatchetResult>(async (resolve, reject) => {\n      try {\n        const keySet = this.getKeySet(currentKeyIndex);\n        if (!keySet) {\n          throw new TypeError(\n            `Cannot ratchet key without a valid keyset of participant ${this.participantIdentity}`,\n          );\n        }\n        const currentMaterial = keySet.material;\n        const chainKey = await ratchet(currentMaterial, this.keyProviderOptions.ratchetSalt);\n        const newMaterial = await importKey(chainKey, currentMaterial.algorithm.name, 'derive');\n        const ratchetResult: RatchetResult = {\n          chainKey,\n          cryptoKey: newMaterial,\n        };\n        if (setKey) {\n          // Set the new key and emit a ratchet event with the ratcheted chain key\n          await this.setKeyFromMaterial(newMaterial, currentKeyIndex, ratchetResult);\n        }\n        resolve(ratchetResult);\n      } catch (e) {\n        reject(e);\n      } finally {\n        this.ratchetPromiseMap.delete(currentKeyIndex);\n      }\n    });\n    this.ratchetPromiseMap.set(currentKeyIndex, ratchetPromise);\n    return ratchetPromise;\n  }\n\n  /**\n   * takes in a key material with `deriveBits` and `deriveKey` set as key usages\n   * and derives encryption keys from the material and sets it on the key ring buffer\n   * together with the material\n   * also resets the valid key property and updates the currentKeyIndex\n   */\n  async setKey(material: CryptoKey, keyIndex = 0) {\n    await this.setKeyFromMaterial(material, keyIndex);\n    this.resetKeyStatus(keyIndex);\n  }\n\n  /**\n   * takes in a key material with `deriveBits` and `deriveKey` set as key usages\n   * and derives encryption keys from the material and sets it on the key ring buffers\n   * together with the material\n   * also updates the currentKeyIndex\n   */\n  async setKeyFromMaterial(\n    material: CryptoKey,\n    keyIndex: number,\n    ratchetedResult: RatchetResult | null = null,\n  ) {\n    const keySet = await deriveKeys(material, this.keyProviderOptions.ratchetSalt);\n    const newIndex = keyIndex >= 0 ? keyIndex % this.cryptoKeyRing.length : this.currentKeyIndex;\n    workerLogger.debug(`setting new key with index ${keyIndex}`, {\n      usage: material.usages,\n      algorithm: material.algorithm,\n      ratchetSalt: this.keyProviderOptions.ratchetSalt,\n    });\n    this.setKeySet(keySet, newIndex, ratchetedResult);\n    if (newIndex >= 0) this.currentKeyIndex = newIndex;\n  }\n\n  setKeySet(keySet: KeySet, keyIndex: number, ratchetedResult: RatchetResult | null = null) {\n    this.cryptoKeyRing[keyIndex % this.cryptoKeyRing.length] = keySet;\n\n    if (ratchetedResult) {\n      this.emit(KeyHandlerEvent.KeyRatcheted, ratchetedResult, this.participantIdentity, keyIndex);\n    }\n  }\n\n  async setCurrentKeyIndex(index: number) {\n    this.currentKeyIndex = index % this.cryptoKeyRing.length;\n    this.resetKeyStatus(index);\n  }\n\n  getCurrentKeyIndex() {\n    return this.currentKeyIndex;\n  }\n\n  /**\n   * returns currently used KeySet or the one at `keyIndex` if provided\n   * @param keyIndex\n   * @returns\n   */\n  getKeySet(keyIndex?: number) {\n    return this.cryptoKeyRing[keyIndex ?? this.currentKeyIndex];\n  }\n}\n","import { workerLogger } from '../../logger';\nimport type { VideoCodec } from '../../room/track/options';\nimport { AsyncQueue } from '../../utils/AsyncQueue';\nimport { KEY_PROVIDER_DEFAULTS } from '../constants';\nimport { CryptorErrorReason } from '../errors';\nimport { CryptorEvent, KeyHandlerEvent } from '../events';\nimport type {\n  DecryptDataResponseMessage,\n  E2EEWorkerMessage,\n  EncryptDataResponseMessage,\n  ErrorMessage,\n  InitAck,\n  KeyProviderOptions,\n  RatchetMessage,\n  RatchetRequestMessage,\n  RatchetResult,\n  ScriptTransformOptions,\n} from '../types';\nimport { DataCryptor } from './DataCryptor';\nimport { FrameCryptor, encryptionEnabledMap } from './FrameCryptor';\nimport { ParticipantKeyHandler } from './ParticipantKeyHandler';\n\nconst participantCryptors: FrameCryptor[] = [];\nconst participantKeys: Map<string, ParticipantKeyHandler> = new Map();\nlet sharedKeyHandler: ParticipantKeyHandler | undefined;\nlet messageQueue = new AsyncQueue();\n\nlet isEncryptionEnabled: boolean = false;\n\nlet useSharedKey: boolean = false;\n\nlet sifTrailer: Uint8Array | undefined;\n\nlet keyProviderOptions: KeyProviderOptions = KEY_PROVIDER_DEFAULTS;\n\nlet rtpMap: Map<number, VideoCodec> = new Map();\n\nworkerLogger.setDefaultLevel('info');\n\nonmessage = (ev) => {\n  messageQueue.run(async () => {\n    const { kind, data }: E2EEWorkerMessage = ev.data;\n\n    switch (kind) {\n      case 'init':\n        workerLogger.setLevel(data.loglevel);\n        workerLogger.info('worker initialized');\n        keyProviderOptions = data.keyProviderOptions;\n        useSharedKey = !!data.keyProviderOptions.sharedKey;\n        // acknowledge init successful\n        const ackMsg: InitAck = {\n          kind: 'initAck',\n          data: { enabled: isEncryptionEnabled },\n        };\n        postMessage(ackMsg);\n        break;\n      case 'enable':\n        setEncryptionEnabled(data.enabled, data.participantIdentity);\n        workerLogger.info(\n          `updated e2ee enabled status for ${data.participantIdentity} to ${data.enabled}`,\n        );\n        // acknowledge enable call successful\n        postMessage(ev.data);\n        break;\n      case 'decode':\n        let cryptor = getTrackCryptor(data.participantIdentity, data.trackId);\n        cryptor.setupTransform(\n          kind,\n          data.readableStream,\n          data.writableStream,\n          data.trackId,\n          data.isReuse,\n          data.codec,\n        );\n        break;\n      case 'encode':\n        let pubCryptor = getTrackCryptor(data.participantIdentity, data.trackId);\n        pubCryptor.setupTransform(\n          kind,\n          data.readableStream,\n          data.writableStream,\n          data.trackId,\n          data.isReuse,\n          data.codec,\n        );\n        break;\n\n      case 'encryptDataRequest':\n        const {\n          payload: encryptedPayload,\n          iv,\n          keyIndex,\n        } = await DataCryptor.encrypt(\n          data.payload,\n          getParticipantKeyHandler(data.participantIdentity),\n        );\n        console.log('encrypted payload', {\n          original: data.payload,\n          encrypted: encryptedPayload,\n          iv,\n        });\n        postMessage({\n          kind: 'encryptDataResponse',\n          data: {\n            payload: encryptedPayload,\n            iv,\n            keyIndex,\n            uuid: data.uuid,\n          },\n        } satisfies EncryptDataResponseMessage);\n        break;\n\n      case 'decryptDataRequest':\n        try {\n          const { payload: decryptedPayload } = await DataCryptor.decrypt(\n            data.payload,\n            data.iv,\n            getParticipantKeyHandler(data.participantIdentity),\n            data.keyIndex,\n          );\n          postMessage({\n            kind: 'decryptDataResponse',\n            data: { payload: decryptedPayload, uuid: data.uuid },\n          } satisfies DecryptDataResponseMessage);\n        } catch (error) {\n          // Send error back to main thread with uuid so it can reject the corresponding promise\n          workerLogger.error('DataCryptor decryption failed', {\n            error,\n            participantIdentity: data.participantIdentity,\n            uuid: data.uuid,\n          });\n          postMessage({\n            kind: 'error',\n            data: {\n              error: error instanceof Error ? error : new Error(String(error)),\n              uuid: data.uuid, // Include uuid to match with the pending request\n            },\n          } satisfies ErrorMessage);\n        }\n        break;\n\n      case 'setKey':\n        if (useSharedKey) {\n          await setSharedKey(data.key, data.keyIndex);\n        } else if (data.participantIdentity) {\n          workerLogger.info(\n            `set participant sender key ${data.participantIdentity} index ${data.keyIndex}`,\n          );\n          await getParticipantKeyHandler(data.participantIdentity).setKey(data.key, data.keyIndex);\n        } else {\n          workerLogger.error('no participant Id was provided and shared key usage is disabled');\n        }\n        break;\n      case 'removeTransform':\n        unsetCryptorParticipant(data.trackId, data.participantIdentity);\n        break;\n      case 'updateCodec':\n        getTrackCryptor(data.participantIdentity, data.trackId).setVideoCodec(data.codec);\n        workerLogger.info('updated codec', {\n          participantIdentity: data.participantIdentity,\n          trackId: data.trackId,\n          codec: data.codec,\n        });\n        break;\n      case 'setRTPMap':\n        // this is only used for the local participant\n        rtpMap = data.map;\n        participantCryptors.forEach((cr) => {\n          if (cr.getParticipantIdentity() === data.participantIdentity) {\n            cr.setRtpMap(data.map);\n          }\n        });\n        break;\n      case 'ratchetRequest':\n        handleRatchetRequest(data);\n        break;\n      case 'setSifTrailer':\n        handleSifTrailer(data.trailer);\n        break;\n      default:\n        break;\n    }\n  });\n};\n\nasync function handleRatchetRequest(data: RatchetRequestMessage['data']) {\n  if (useSharedKey) {\n    const keyHandler = getSharedKeyHandler();\n    await keyHandler.ratchetKey(data.keyIndex);\n    keyHandler.resetKeyStatus();\n  } else if (data.participantIdentity) {\n    const keyHandler = getParticipantKeyHandler(data.participantIdentity);\n    await keyHandler.ratchetKey(data.keyIndex);\n    keyHandler.resetKeyStatus();\n  } else {\n    workerLogger.error(\n      'no participant Id was provided for ratchet request and shared key usage is disabled',\n    );\n  }\n}\n\nfunction getTrackCryptor(participantIdentity: string, trackId: string) {\n  let cryptors = participantCryptors.filter((c) => c.getTrackId() === trackId);\n  if (cryptors.length > 1) {\n    const debugInfo = cryptors\n      .map((c) => {\n        return { participant: c.getParticipantIdentity() };\n      })\n      .join(',');\n    workerLogger.error(\n      `Found multiple cryptors for the same trackID ${trackId}. target participant: ${participantIdentity} `,\n      { participants: debugInfo },\n    );\n  }\n  let cryptor = cryptors[0];\n  if (!cryptor) {\n    workerLogger.info('creating new cryptor for', { participantIdentity, trackId });\n    if (!keyProviderOptions) {\n      throw Error('Missing keyProvider options');\n    }\n    cryptor = new FrameCryptor({\n      participantIdentity,\n      keys: getParticipantKeyHandler(participantIdentity),\n      keyProviderOptions,\n      sifTrailer,\n    });\n    cryptor.setRtpMap(rtpMap);\n    setupCryptorErrorEvents(cryptor);\n    participantCryptors.push(cryptor);\n  } else if (participantIdentity !== cryptor.getParticipantIdentity()) {\n    // assign new participant id to track cryptor and pass in correct key handler\n    cryptor.setParticipant(participantIdentity, getParticipantKeyHandler(participantIdentity));\n  }\n\n  return cryptor;\n}\n\nfunction getParticipantKeyHandler(participantIdentity: string) {\n  if (useSharedKey) {\n    return getSharedKeyHandler();\n  }\n  let keys = participantKeys.get(participantIdentity);\n  if (!keys) {\n    keys = new ParticipantKeyHandler(participantIdentity, keyProviderOptions);\n    keys.on(KeyHandlerEvent.KeyRatcheted, emitRatchetedKeys);\n    participantKeys.set(participantIdentity, keys);\n  }\n  return keys;\n}\n\nfunction getSharedKeyHandler() {\n  if (!sharedKeyHandler) {\n    workerLogger.debug('creating new shared key handler');\n    sharedKeyHandler = new ParticipantKeyHandler('shared-key', keyProviderOptions);\n  }\n  return sharedKeyHandler;\n}\n\nfunction unsetCryptorParticipant(trackId: string, participantIdentity: string) {\n  const cryptors = participantCryptors.filter(\n    (c) => c.getParticipantIdentity() === participantIdentity && c.getTrackId() === trackId,\n  );\n  if (cryptors.length > 1) {\n    workerLogger.error('Found multiple cryptors for the same participant and trackID combination', {\n      trackId,\n      participantIdentity,\n    });\n  }\n  const cryptor = cryptors[0];\n  if (!cryptor) {\n    workerLogger.warn('Could not unset participant on cryptor', { trackId, participantIdentity });\n  } else {\n    cryptor.unsetParticipant();\n  }\n}\n\nfunction setEncryptionEnabled(enable: boolean, participantIdentity: string) {\n  workerLogger.debug(`setting encryption enabled for all tracks of ${participantIdentity}`, {\n    enable,\n  });\n  encryptionEnabledMap.set(participantIdentity, enable);\n}\n\nasync function setSharedKey(key: CryptoKey, index?: number) {\n  workerLogger.info('set shared key', { index });\n  await getSharedKeyHandler().setKey(key, index);\n}\n\nfunction setupCryptorErrorEvents(cryptor: FrameCryptor) {\n  cryptor.on(CryptorEvent.Error, (error) => {\n    const msg: ErrorMessage = {\n      kind: 'error',\n      data: {\n        error: new Error(`${CryptorErrorReason[error.reason]}: ${error.message}`),\n        participantIdentity: error.participantIdentity,\n      },\n    };\n    postMessage(msg);\n  });\n}\n\nfunction emitRatchetedKeys(\n  ratchetResult: RatchetResult,\n  participantIdentity: string,\n  keyIndex?: number,\n) {\n  const msg: RatchetMessage = {\n    kind: `ratchetKey`,\n    data: {\n      participantIdentity,\n      keyIndex,\n      ratchetResult,\n    },\n  };\n  postMessage(msg);\n}\n\nfunction handleSifTrailer(trailer: Uint8Array) {\n  sifTrailer = trailer;\n  participantCryptors.forEach((c) => {\n    c.setSifTrailer(trailer);\n  });\n}\n\n// Operations using RTCRtpScriptTransform.\n// @ts-ignore\nif (self.RTCTransformEvent) {\n  workerLogger.debug('setup transform event');\n  // @ts-ignore\n  self.onrtctransform = (event: RTCTransformEvent) => {\n    // @ts-ignore\n    const transformer = event.transformer;\n    workerLogger.debug('transformer', transformer);\n\n    const { kind, participantIdentity, trackId, codec } =\n      transformer.options as ScriptTransformOptions;\n    const cryptor = getTrackCryptor(participantIdentity, trackId);\n    workerLogger.debug('transform', { codec });\n    cryptor.setupTransform(kind, transformer.readable, transformer.writable, trackId, false, codec);\n  };\n}\n"],"names":["root","definition","LogLevel","LoggerNames","noop","undefinedType","isIE","window","navigator","test","userAgent","logMethods","_loggersByName","defaultLogger","bindMethod","obj","methodName","method","bind","Function","prototype","call","e","apply","arguments","traceForIE","console","log","trace","replaceLoggingMethods","level","this","getLevel","i","length","methodFactory","name","debug","levels","SILENT","enableLoggingWhenConsoleArrives","defaultMethodFactory","_level","_loggerName","undefined","realMethod","Logger","factory","inheritedLevel","defaultLevel","userLevel","self","storageKey","getPersistedLevel","storedLevel","localStorage","ignore","cookie","document","cookieName","encodeURIComponent","location","indexOf","exec","slice","normalizeLevel","input","toUpperCase","TypeError","TRACE","DEBUG","INFO","WARN","ERROR","setLevel","persist","levelNum","levelName","persistLevelIfPossible","setDefaultLevel","resetLevel","removeItem","clearPersistedLevel","enableAll","disableAll","rebuild","childName","initialLevel","getLogger","logger","_log","noConflict","getLoggers","exports","module","livekitLogger","Object","values","map","info","workerLogger","QueueTaskStatus","_","constructor","o","_locking","Promise","resolve","_locks","isLocked","lock","s","t","l","unlockNext","c","then","ENCRYPTION_ALGORITHM","UNENCRYPTED_BYTES","key","delta","audio","empty","KEY_PROVIDER_DEFAULTS","sharedKey","ratchetSalt","ratchetWindowSize","failureTolerance","keyringSize","LivekitError","Error","code","message","options","super","cause","ConnectionErrorReason","DataStreamErrorReason","MediaDeviceFailure","CryptorErrorReason","KeyProviderEvent","KeyHandlerEvent","EncryptionEvent","CryptorEvent","getFailure","error","NotFound","PermissionDenied","DeviceInUse","Other","CryptorError","reason","InternalError","participantIdentity","getAlgoOptions","algorithmName","salt","encodedSalt","TextEncoder","encode","hash","ArrayBuffer","iterations","concat","deriveKeys","material","algorithmOptions","algorithm","encryptionKey","crypto","subtle","deriveKey","DataCryptor","makeIV","timestamp","iv","ivView","DataView","randomBytes","getRandomValues","Uint32Array","setUint32","sendCount","encrypt","data","keys","performance","now","keySet","getKeySet","cipherText","Uint8Array","payload","keyIndex","getCurrentKeyIndex","decrypt","data_1","iv_1","keys_1","__awaiter","initialMaterial","ratchetOpts","ratchetCount","plainText","keyProviderOptions","ratchetedKeySet","ratchetResult","ratchetKey","cryptoKey","decryptedData","setKeySet","setCurrentKeyIndex","warn","InvalidKey","ReflectOwnKeys","R","Reflect","ReflectApply","target","receiver","args","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","NumberIsNaN","Number","isNaN","value","EventEmitter","init","eventsModule","once","emitter","reject","errorListener","err","removeListener","resolver","eventTargetAgnosticAddListener","handler","flags","on","addErrorHandlerIfEventEmitter","_events","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","_getMaxListeners","that","_addListener","type","prepend","m","events","existing","warning","create","newListener","emit","unshift","push","warned","w","String","count","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","_listeners","unwrap","evlistener","arr","ret","Array","unwrapListeners","arrayClone","listenerCount","n","copy","addEventListener","wrapListener","arg","removeEventListener","defineProperty","enumerable","get","set","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","er","context","len","listeners","addListener","prependListener","prependOnceListener","list","position","originalListener","shift","index","pop","spliceOne","off","removeAllListeners","rawListeners","eventNames","kH264NaluTypeMask","H264NALUType","H265NALUType","parseH264NALUType","startByte","parseH265NALUType","firstByte","isH264SliceNALU","naluType","SLICE_IDR","SLICE_NON_IDR","isH265SliceNALU","TRAIL_N","TRAIL_R","TSA_N","TSA_R","STSA_N","STSA_R","RADL_N","RADL_R","RASL_N","RASL_R","BLA_W_LP","BLA_W_RADL","BLA_N_LP","IDR_W_RADL","IDR_N_LP","CRA_NUT","processNALUsForEncryption","knownCodec","naluIndices","stream","result","start","pos","searchLength","end","startCodeLength","findNALUIndices","detectedCodec","naluIndex","detectCodecFromNALUs","unencryptedBytes","requiresNALUProcessing","codec","findSliceNALUUnencryptedBytes","CryptoHashes","identifySifPayload","hashBuffer","digest","hashArray","from","b","toString","padStart","join","cryptoHash","encryptionEnabledMap","Map","BaseFrameCryptor","encodeFunction","encodedFrame","controller","decodeFunction","FrameCryptor","opts","lastErrorTimestamp","errorCounts","ERROR_THROTTLE_MS","MAX_ERRORS_PER_MINUTE","ERROR_WINDOW_MS","sendCounts","rtpMap","sifTrailer","_a","logContext","participant","mediaTrackId","trackId","fallbackCodec","videoCodec","setParticipant","id","newParticipant","hadPreviousParticipant","oldParticipant","unsetParticipant","currentTransform","isEnabled","getParticipantIdentity","getTrackId","setVideoCodec","setRtpMap","setupTransform","operation","readable","writable","isReuse","assign","passedTrackId","hasCurrentTransform","symbol","Symbol","transformFn","transformStream","TransformStream","transform","transformer","pipeThrough","pipeTo","catch","finally","setSifTrailer","trailer","shouldEmitError","errorKey","Date","lastErrorTime","errorCount","_b","emitThrottledError","byteLength","enqueue","MissingKey","getMetadata","synchronizationSource","frameInfo","getUnencryptedBytes","frameHeader","frameTrailer","additionalData","newDataWithoutHeader","data_in","dataOut","numConsecutiveZeros","byte","writeRbsp","newData","buffer","frameData","trailerBytes","every","isFrameServerInjected","hasInvalidKeyAtIndex","decodedFrame","decryptFrame","decryptionSuccess","hasValidKey","decryptionFailure","encodedFrame_1","keyIndex_1","_this","encryptedData","needsRbspUnescaping","parseRbsp","newUint8","ivLength","cipherTextStart","cipherTextLength","RTCEncodedAudioFrame","frame","has","Math","floor","random","isVideoFrame","getVideoCodec","oldCodec","naluResult","size","payloadType","ParticipantKeyHandler","currentKeyIndex","cryptoKeyRing","fill","decryptionFailureCounts","ratchetPromiseMap","resetKeyStatus","setKey","existingPromise","ratchetPromise","currentMaterial","chainKey","deriveBits","ratchet","newMaterial","keyBytes_1","keyBytes","usage","importKey","setKeyFromMaterial","delete","material_1","_this2","ratchetedResult","newIndex","usages","KeyRatcheted","participantCryptors","participantKeys","sharedKeyHandler","messageQueue","pendingTasks","taskMutex","Mutex","nextTaskIndex","run","task","taskInfo","enqueuedAt","status","WAITING","unlock","executedAt","RUNNING","COMPLETED","flush","snapshot","useSharedKey","getTrackCryptor","cryptors","filter","debugInfo","participants","cryptor","getParticipantKeyHandler","msg","kind","postMessage","setupCryptorErrorEvents","getSharedKeyHandler","emitRatchetedKeys","onmessage","ev","loglevel","enabled","enable","readableStream","writableStream","encryptedPayload","original","encrypted","uuid","decryptedPayload","setSharedKey","unsetCryptorParticipant","forEach","cr","keyHandler","handleRatchetRequest","RTCTransformEvent","onrtctransform","event"],"mappings":"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","x_google_ignoreList":[0,3,10]}