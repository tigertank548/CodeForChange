import { DisconnectReason, RequestResponse_Reason } from '@livekit/protocol';
/** Base error that all LiveKit specific custom errors inherit from. */
export declare class LivekitError extends Error {
    code: number;
    cause?: unknown;
    constructor(code: number, message?: string, options?: {
        cause?: unknown;
    });
}
/**
 * LiveKit specific error type representing an error with an associated set of reasons.
 * Use this to represent an error with multiple different but contextually related variants.
 * */
export declare abstract class LivekitReasonedError<Reason> extends LivekitError {
    abstract reason: Reason;
    abstract reasonName: string;
}
export declare class SimulatedError extends LivekitError {
    readonly name = "simulated";
    constructor(message?: string);
}
export declare enum ConnectionErrorReason {
    NotAllowed = 0,
    ServerUnreachable = 1,
    InternalError = 2,
    Cancelled = 3,
    LeaveRequest = 4,
    Timeout = 5,
    WebSocket = 6,
    ServiceNotFound = 7
}
type NotAllowed = {
    reason: ConnectionErrorReason.NotAllowed;
    status: number;
    context?: unknown;
};
type InternalError = {
    reason: ConnectionErrorReason.InternalError;
    status: never;
    context?: {
        status?: number;
        statusText?: string;
    };
};
type ConnectionTimeout = {
    reason: ConnectionErrorReason.Timeout;
    status: never;
    context: never;
};
type LeaveRequest = {
    reason: ConnectionErrorReason.LeaveRequest;
    status: never;
    context: DisconnectReason;
};
type Cancelled = {
    reason: ConnectionErrorReason.Cancelled;
    status: never;
    context: never;
};
type ServerUnreachable = {
    reason: ConnectionErrorReason.ServerUnreachable;
    status?: number;
    context?: never;
};
type WebSocket = {
    reason: ConnectionErrorReason.WebSocket;
    status?: number;
    context?: string;
};
type ServiceNotFound = {
    reason: ConnectionErrorReason.ServiceNotFound;
    status: never;
    context: string;
};
type ConnectionErrorVariants = NotAllowed | ConnectionTimeout | LeaveRequest | InternalError | Cancelled | ServerUnreachable | WebSocket | ServiceNotFound;
export declare class ConnectionError<Variant extends ConnectionErrorVariants = ConnectionErrorVariants> extends LivekitReasonedError<Variant['reason']> {
    status?: Variant['status'];
    context: Variant['context'];
    reason: Variant['reason'];
    reasonName: string;
    readonly name = "ConnectionError";
    protected constructor(message: string, reason: Variant['reason'], status?: Variant['status'], context?: Variant['context']);
    static notAllowed(message: string, status: number, context?: unknown): ConnectionError<NotAllowed>;
    static timeout(message: string): ConnectionError<ConnectionTimeout>;
    static leaveRequest(message: string, context: DisconnectReason): ConnectionError<LeaveRequest>;
    static internal(message: string, context?: {
        status?: number;
        statusText?: string;
    }): ConnectionError<InternalError>;
    static cancelled(message: string): ConnectionError<Cancelled>;
    static serverUnreachable(message: string, status?: number): ConnectionError<ServerUnreachable>;
    static websocket(message: string, status?: number, reason?: string): ConnectionError<WebSocket>;
    static serviceNotFound(message: string, serviceName: 'v0-rtc'): ConnectionError<ServiceNotFound>;
}
export declare class DeviceUnsupportedError extends LivekitError {
    readonly name = "DeviceUnsupportedError";
    constructor(message?: string);
}
export declare class TrackInvalidError extends LivekitError {
    readonly name = "TrackInvalidError";
    constructor(message?: string);
}
export declare class UnsupportedServer extends LivekitError {
    readonly name = "UnsupportedServer";
    constructor(message?: string);
}
export declare class UnexpectedConnectionState extends LivekitError {
    readonly name = "UnexpectedConnectionState";
    constructor(message?: string);
}
export declare class NegotiationError extends LivekitError {
    readonly name = "NegotiationError";
    constructor(message?: string);
}
export declare class PublishDataError extends LivekitError {
    readonly name = "PublishDataError";
    constructor(message?: string);
}
export declare class PublishTrackError extends LivekitError {
    readonly name = "PublishTrackError";
    status: number;
    constructor(message: string, status: number);
}
export type RequestErrorReason = Exclude<RequestResponse_Reason, RequestResponse_Reason.OK> | 'TimeoutError';
export declare class SignalRequestError extends LivekitReasonedError<RequestErrorReason> {
    readonly name = "SignalRequestError";
    reason: RequestErrorReason;
    reasonName: string;
    constructor(message: string, reason: RequestErrorReason);
}
export declare enum DataStreamErrorReason {
    AlreadyOpened = 0,
    AbnormalEnd = 1,
    DecodeFailed = 2,
    LengthExceeded = 3,
    Incomplete = 4,
    HandlerAlreadyRegistered = 7,
    EncryptionTypeMismatch = 8
}
export declare class DataStreamError extends LivekitReasonedError<DataStreamErrorReason> {
    readonly name = "DataStreamError";
    reason: DataStreamErrorReason;
    reasonName: string;
    constructor(message: string, reason: DataStreamErrorReason);
}
export declare class SignalReconnectError extends LivekitError {
    readonly name = "SignalReconnectError";
    constructor(message?: string);
}
export declare enum MediaDeviceFailure {
    PermissionDenied = "PermissionDenied",
    NotFound = "NotFound",
    DeviceInUse = "DeviceInUse",
    Other = "Other"
}
export declare namespace MediaDeviceFailure {
    function getFailure(error: any): MediaDeviceFailure | undefined;
}
export {};
//# sourceMappingURL=errors.d.ts.map