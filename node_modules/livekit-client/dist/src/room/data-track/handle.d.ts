import { type Throws } from '../../utils/throws';
import { LivekitReasonedError } from '../errors';
export declare enum DataTrackHandleErrorReason {
    Reserved = 0,
    TooLarge = 1
}
export declare class DataTrackHandleError<Reason extends DataTrackHandleErrorReason = DataTrackHandleErrorReason> extends LivekitReasonedError<DataTrackHandleErrorReason> {
    readonly name = "DataTrackHandleError";
    reason: Reason;
    reasonName: string;
    constructor(message: string, reason: Reason);
    isReason<R extends DataTrackHandleErrorReason>(reason: R): this is DataTrackHandleError<R>;
    static tooLarge(): DataTrackHandleError<DataTrackHandleErrorReason.TooLarge>;
    static reserved(value: number): DataTrackHandleError<DataTrackHandleErrorReason.Reserved>;
}
export declare class DataTrackHandle {
    value: number;
    static fromNumber(raw: number): Throws<DataTrackHandle, DataTrackHandleError<DataTrackHandleErrorReason.TooLarge> | DataTrackHandleError<DataTrackHandleErrorReason.Reserved>>;
    constructor(raw: number);
}
/** Manage allocating new handles which don't conflict over the lifetime of the client. */
export declare class DataTrackHandleAllocator {
    static value: number;
    /** Returns a unique track handle for the next publication, if one can be obtained. */
    static get(): DataTrackHandle | null;
}
//# sourceMappingURL=handle.d.ts.map